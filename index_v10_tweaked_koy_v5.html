<!DOCTYPE html>

<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Ankara’nın Sinemasal Kartografyası</title>
<link href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

<script>
  (function(){
    function ensureHidden() {
      document.querySelectorAll('.leaflet-control-attribution, .leaflet-control-scale').forEach(el => { try{ el.remove(); }catch(e){} });
      const s = document.createElement('style');
      s.id = 'force-hide-leaflet-credits';
      s.innerHTML = '.leaflet-control-attribution, .leaflet-control-scale{display:none !important; visibility:hidden !important; height:0 !important; margin:0 !important; padding:0 !important;}';
      if(!document.getElementById('force-hide-leaflet-credits')) document.head.appendChild(s);
    }
    ensureHidden();
    setTimeout(ensureHidden, 250);
    setTimeout(ensureHidden, 800);
    window._ensureHiddenInterval = setInterval(ensureHidden, 1200);

    function setupScale(map){
      if(!map) return;
      if(window._ensureHiddenInterval) { clearInterval(window._ensureHiddenInterval); window._ensureHiddenInterval = null; }
      let scaleDiv = document.querySelector('.custom-scale');
      if(!scaleDiv){
        scaleDiv = L.DomUtil.create('div', 'custom-scale');
        scaleDiv.style.position = 'absolute';
        scaleDiv.style.bottom = '8px';
        scaleDiv.style.right = '75px';
        scaleDiv.style.background = 'rgba(255,255,255,0.95)';
        scaleDiv.style.padding = '4px 8px';
        scaleDiv.style.borderRadius = '4px';
        scaleDiv.style.fontSize = '11px';
        scaleDiv.style.fontWeight = '600';
        scaleDiv.style.boxShadow = '0 1px 2px rgba(0,0,0,0.08)';
        scaleDiv.style.zIndex = '1000';
        if(map.getContainer()) map.getContainer().appendChild(scaleDiv);
      }
      function updateScale() {
        const lat = map.getCenter().lat * Math.PI / 180;
        const metersPerPixel = 40075016.686 * Math.cos(lat) / Math.pow(2, map.getZoom() + 8);
        const scale = Math.round(1 / (metersPerPixel / 0.000264583));
        scaleDiv.textContent = '1:' + scale.toLocaleString('tr-TR');
      }
      map.on('zoomend moveend viewreset', updateScale);
      updateScale();
      const z = document.querySelector('.leaflet-control-zoom');
      if(z){ z.style.right = '10px'; z.style.bottom = '30px'; z.style.transition = 'right 0.2s, bottom 0.2s'; }
    }

</script>
<style>
html,body{
  height:100%;
  margin:0;
  font-family:-apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;
  background:#f7f9fb;
  overflow:hidden;
}


#sidebar{
  position:absolute;
  left:0;top:0;
  width:340px;height:100%;
  background:#fff;
  border-right:1px solid #e6eef6;
  box-shadow:2px 0 6px rgba(0,0,0,0.06);
  padding:18px;
  box-sizing:border-box;
  overflow:auto;
  transition:transform .35s ease;
  z-index:1200;

  -webkit-overflow-scrolling: touch;
  touch-action: pan-y;
  overscroll-behavior: contain;
}
#sidebar.closed{transform:translateX(-100%);box-shadow:none;border-right:none;}
#toggle-btn{
  position:absolute;
  top:20px;left:340px;
  width:28px;height:48px;
  background:#fff;border:1px solid #d0d7df;border-left:none;
  border-radius:0 6px 6px 0;
  display:flex;align-items:center;justify-content:center;
  cursor:pointer;z-index:2000;
  box-shadow:0 1px 3px rgba(0,0,0,0.15);
  transition:background 0.2s ease, left .35s ease;
}
#toggle-btn:hover{background:#f3f4f6;}
#toggle-btn span{font-size:14pt;color:#e5e7eb;user-select:none;}

#sidebar .description{
font-weight:400;font-style: normal;font-size:8pt;color:#445;line-height:1.25;margin-bottom:12px;
  
  word-spacing: normal;
  letter-spacing: normal;

  
  text-align-last: left;
  text-align: left !important;
}
#search{width:100%;padding:6px 8px;font-size:16px;font-style:italic;border:1px solid #d0d7df;border-radius:6px;margin-bottom:12px;box-sizing:border-box;}
#search:focus { outline: none !important; }

.film{margin-bottom:10px;border-bottom:1px solid #f0f4f8;padding-bottom:8px;}
#film-list{margin-bottom:0 !important;padding-bottom:0 !important;}

.film:last-of-type{margin-bottom:0;border-bottom:none;padding-bottom:0;}
.film-title{cursor:pointer;font-weight:500;font-size:11pt;color:#e5e7eb;margin-bottom:6px;}
.mekan-list{list-style:disc;margin:0 0 0 18px;padding:0;display:none;}
.mekan-list li{font-weight:400;font-size:9pt;margin-bottom:6px;cursor:pointer;color:#e5e7eb;}
.mekan-list li:hover{text-decoration: none;}
#map{position:absolute;left:0;top:0;right:0;bottom:0;z-index:1;}
.leaflet-control-zoom{position:absolute !important;bottom: 30px;right:20px;transform: scale(0.75);border-radius:6px;box-shadow:0 1px 2px rgba(0,0,0,0.1);}
.leaflet-popup-content img{max-width:200px;height:auto;border-radius:6px;margin-top:6px;display:block;}
.leaflet-popup-content-wrapper {width:280px !important;max-width:280px !important;}
.leaflet-popup-content { font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important; font-weight: 400; }



.numeric-scale {
      position:absolute;
      top:8px;
      bottom:auto;
      right:8px;
      z-index:1000;
      background:rgba(255,255,255,0.7);
      border-radius:4px;
      padding:2px 6px;
      font-size:10px;
      color:#374151;
      font-family:system-ui, sans-serif;
      pointer-events:none;
    }
    .map-attribution{
      position:absolute;
      bottom:6px;
      right:8px;
      z-index:1000;
      background:rgba(255,255,255,0.7);
      border-radius:4px;
      padding:2px 6px;
      font-size:10px;
      color:#374151;
      font-family:system-ui, sans-serif;
      line-height:1.2;
    }
    .map-attribution .credit-full{ display:inline; }
    .map-attribution .credit-short{ display:none; }

.map-attribution .credit-short{ display:none; }
    }

    .map-attribution a{
      color:#374151;
      text-decoration:none;
    }
    .map-attribution a:hover{ text-decoration: none; }






.leaflet-control-zoom {
  display: none !important;
  visibility: hidden !important;
}




.leaflet-control-attribution {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
  margin: 0 !important;
  padding: 0 !important;
}



.tab-btn.active {
  background: #e8ecf3 !important;
  font-weight: 600 !important;
  border-color: #ccc !important;
}


.tab-btn {
  transition: background-color 0.25s ease, box-shadow 0.25s ease, transform 0.15s ease;
}
.tab-btn:hover {
  background: #f1f4f9 !important;
  box-shadow: 0 1px 4px rgba(0,0,0,0.08);
  transform: translateY(-1px);
}


.tab-content {
  display: none;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.4s ease, visibility 0.4s ease;
}
.tab-content.active-visible {
  display: block;
  opacity: 1;
  visibility: visible;
  position: relative;
  z-index: 10;
}
.tab-content {
  display: none;
  opacity: 0;
  transition: opacity 0.4s ease;
}
.tab-content.active-visible {
  display: block;
  opacity: 1;
}


.film-title {
  transition: background-color 0.18s ease, transform 0.12s ease, box-shadow 0.18s ease, color 0.18s ease;
  padding:6px 8px;
  border-radius:6px;
}
.film-title:hover {
  background: #f1f4f9;
  transform: translateY(-2px);
  box-shadow: 0 1px 6px rgba(0,0,0,0.06);
  color: #111;
}
.mekan-list li {
  transition: transform 0.16s ease, color 0.16s ease, padding-left 0.16s ease;
  padding-left:2px;
  border-radius:4px;
}
.mekan-list li:hover {
  transform: translateX(4px);
  color: #111;
  text-decoration: none;
  background: rgba(0,0,0,0.01);
  padding-left:6px;
}

#filter-info { font-size:12px; color:#0f172a; display:none; }
#filter-info .btn-clear{
  /* Keep text size as-is (inherit), just reduce button box height */
  font: inherit;
  padding: 0 10px !important;
  height: 22px !important;
  min-height: 22px !important;
  line-height: 22px !important;
  display: inline-flex;
  align-items: center;
  border-radius: 8px;
}



.film-title.selected {
  background: #e8ecf3 !important;
  font-weight: 600;
  box-shadow: 0 1px 4px rgba(0,0,0,0.08);
  border-radius: 6px;
  transform: translateY(-1px);
}


#map-filter-info {
  color: #444455 !important;
}
#map-filter-info .btn-clear:hover {
  background: #f2f4fa !important;
}

#map-filter-info {
  color: #444455 !important;
}

#map-filter-info .btn-clear {
  margin-left: 8px;
  cursor: pointer;
  font-weight: 500;
  background: #f2f3f7; 
  color: #333;
  border: none; 
  border-radius: 6px;
  padding: 6px 10px;
  transition: background-color 0.25s ease, box-shadow 0.25s ease, transform 0.15s ease;
}

#map-filter-info .btn-clear:hover {
  background: #f2f4fa !important;
  box-shadow: 0 1px 4px rgba(0,0,0,0.08);
  transform: translateY(-1px);
}


@media (max-width: 768px) {

  .tab-btn {
    color: #333 !important;
  }


  #sidebar {
    width: 200px !important;
  }


  #toggle-btn {
    left: 200px !important;
  }


  #sidebar.closed + #toggle-btn {
    left: 0 !important;
  }
}



@media (max-width: 768px) {

  #sidebar {
    width: 220px !important;
  }


  #toggle-btn {
    left: 220px !important;
  }

  #sidebar.closed + #toggle-btn {
    left: 0 !important;
  }


  #map-filter-info {
    width: 90% !important;
    max-width: 90% !important;
    font-size: 11px !important;
    padding: 4px 8px !important;
    text-align: center !important;
    bottom: 10px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    border-radius: 8px !important;
  }
}


@media (max-width: 768px) {
  .numeric-scale {
    display: none !important;
  }
}


@media (max-width: 768px) {
  .film-title {
    font-size: 10pt !important;
  }
}



.leaflet-popup-content img[src=""], 
.leaflet-popup-content img:not([src]), 
.leaflet-popup-content img[src*="lh3.googleusercontent.com"],
.leaflet-popup-content img[src*="mymaps.usercontent.google.com"] {
  display: none !important;
}


.carousel-container {
  margin-top: 4px;
  display: inline-block;
}

.carousel-controls {
  margin-top: 4px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.carousel-buttons {
  display: flex;
  gap: 4px;
}

.carousel-btn {
  border: 1px solid #d0d7df;
  background: #f5f7fa;
  border-radius: 4px;
  padding: 2px 6px;
  font-size: 11px;
  line-height: 1.2;
  cursor: pointer;
  font-family: inherit;
  color: #333;
}

.carousel-btn:hover {
  background: #e8ecf3;
}

.carousel-counter {
  font-size: 10px;
  color: #555;
  padding: 2px 6px;
  border-radius: 4px;
  border: 1px solid #d0d7df;
  background: #f9fafb;
  font-family: inherit;
}


.period-btn {
  display:block;
  width:100%;
  text-align:left;
  padding:6px 8px;
  margin-bottom:6px;
  font-size:11pt;
  border:1px solid #f0f4f8;
  border-radius:6px;
  background:#fff;
  color:#e5e7eb;
  cursor:pointer;
  transition: background-color 0.18s ease, transform 0.12s ease, box-shadow 0.18s ease;
}
.period-btn:hover {
  background:#f1f4f9;
  transform: translateY(-2px);
  box-shadow:0 1px 6px rgba(0,0,0,0.06);
}
.period-btn.active {
  background:#e8ecf3 !important;
  font-weight:600 !important;
  box-shadow:0 1px 4px rgba(0,0,0,0.08);
  transform: translateY(-1px);
}

#map-filter-info .btn-clear {
  border: none !important;
  outline: none !important;
  box-shadow: none !important;
}

.description-justify{
  text-align: justify;
  text-align-last: left;
}

.cc-license{

  font-size: 8pt;
  line-height: 1.25;
  color: #9ca3af;
  margin-top: 6px;
  
  text-align-last: left;
  text-align: left !important;
}

.cc-license a{
  color: #374151;
  text-decoration: none;
}
.cc-license a:hover{
  text-decoration: none;
}

/* --- Tab3: seçili poligon özeti + film listesi --- */
.polygon-summary{
  margin: 6px 0 10px 0;
  padding: 10px 10px;
  border: 1px solid #e63946;
  border-radius: 10px;
  background: rgba(2,6,23,0.6);
  box-shadow: 0 0 0 1px rgba(230,57,70,0.35),  0 6px 16px rgba(0,0,0,0.35);
}
.polygon-kpis{
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 10px;
  margin-top: 8px;
}
.polygon-kpis .k{
  display:block;
  font-size: 10px;
  letter-spacing: .10em;
  text-transform: uppercase;
  color: rgba(156,163,175,0.95);
}
.polygon-kpis .v{
  display:block;
  font-size: 14px;
  font-weight: 700;
  color: #e5e7eb;
  margin-top: 2px;
}
.polygon-kpi-sub{
  margin-top: 6px;
  font-size: 10px;
  color: rgba(156,163,175,0.95);
}

.fi-ico{display:inline-block;margin-right:8px;}
#map-filter-info .btn-clear{
  padding: 0 10px !important;
  height: 22px !important;
  min-height: 22px !important;
  line-height: 22px !important;
}
.period-row{
  margin-top: 10px;
  display: flex;
  gap: 14px;
  flex-wrap: wrap;
  align-items: center;
}
.period-item{
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-size: 10pt;
  color: #cbd5f5;
  letter-spacing: 0.2px;
}
.period-box{
  width: 10px;
  height: 10px;
  border-radius: 3px;
  border: 1px solid #334155;
  background: rgba(148,163,184,0.12);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.18);
}
.period-box.on{
  background: #e63946;
  border-color: #e63946;
  box-shadow: 0 0 0 1px rgba(230,57,70,0.55);
}

/* Tab3: dönem göstergeleri tek satır + KPI etiketi rengi */
.period-row{
  margin-top: 10px;
  display: flex;
  gap: 12px;
  flex-wrap: nowrap;
  align-items: center;
  white-space: nowrap;
}
.period-item{
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-size: 9.5pt;
  color: #9ca3af; /* KPI etiketi (ROTA vb.) ile uyumlu */
  letter-spacing: 0.1px;
  white-space: nowrap;
}
.period-box{
  width: 10px;
  height: 10px;
  border-radius: 3px;
  border: 1px solid #334155;
  background: rgba(148,163,184,0.12);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.18);
  flex: 0 0 auto;
}
.period-box.on{
  background: #e63946;
  border-color: #e63946;
  box-shadow: 0 0 0 1px rgba(230,57,70,0.55);
}

/* FIX (mobil): Tab3 dönem satırı taşmasın, gerektiğinde alt satıra kırılsın */
@media (max-width: 768px){
  .period-row{
    flex-wrap: wrap !important;
    white-space: normal !important;
    gap: 10px 12px !important;
  }
  .period-item{
    font-size: 9pt !important;
  }
}

</style>

<style>
.leaflet-popup-content .carousel-image {
    display: none !important;
}
.leaflet-popup-content .carousel-image.active {
    display: block !important;
}
</style>


<style>
/* --- Sinematik koyu tema override'ları --- */

#sidebar .description{

  
  text-align-last: left;
  text-align: left !important;
}


body {
  background: #020617;
  color: #e5e7eb;
}

#sidebar {
  background: #020617;
  border-right: 1px solid #111827;
  box-shadow: 2px 0 12px rgba(0,0,0,0.65);
}

#sidebar h1 {
  color: #e5e7eb;
}

#sidebar .description{

  color: #9ca3af;
  text-align: left !important;
}

#toggle-btn {
  background: #020617;
  border-color: #111827;
}

#toggle-btn:hover {
  background: #1a2235;
}

#search {
  background: #020617;
  border-color: #1f2933;
  color: #e5e7eb;
}

#search::placeholder {
  color: #6b7280;
}

.film-title {
  display: block;
  width: 100%;
  text-align: left;
  background: #020617;
  border: 1px solid #1f2933;
  border-radius: 6px;
  padding: 6px 8px;
  margin: 0 0 6px 0;
  color: #e5e7eb;
  box-sizing: border-box;
}
.film {
  border-bottom: none !important;
  padding-bottom: 0 !important;
  margin-bottom: 8px;
}


.film-title:hover {
  background: #1a2235;
  border-color: #334155;
  color: #e5e7eb;
}

.film-title.selected {
  background: #1a2235 !important;
  border-color: #e63946 !important;
  box-shadow: 0 0 0 1px rgba(230,57,70,0.45);
  transform: none !important;
}

.mekan-list li {
  color: #cbd5f5;
}

.mekan-list li:hover {
  background: #1a2235;
  color: #e5e7eb;
}

.tab-btn {
  background: #020617 !important;
  border-color: #1f2933 !important;
  color: #e5e7eb !important;
}

.tab-btn:hover {
  background: #1a2235 !important;
}

.tab-btn.active {
  background: #1a2235 !important;
  border-color: #e63946 !important;
}

.period-btn {
  background: #020617;
  border-color: #1f2933;
  color: #e5e7eb;
}

.period-btn:hover {
  background: #1a2235;
}

.period-btn.active {
  background: #1a2235 !important;
  border-color: #e63946 !important;
  box-shadow: 0 0 0 1px rgba(230,57,70,0.4);
}

.leaflet-popup-content-wrapper {
  background: #020617;
  color: #e5e7eb;
  border: 1px solid #111827;
}

.leaflet-popup-content {
  color: #e5e7eb;
}
.leaflet-tooltip{
  background:#020617 !important;
  color:#e5e7eb !important;
  border:1px solid #111827 !important;
  border-radius:10px !important;
  padding:6px 10px !important;
  box-shadow: 0 10px 22px rgba(0,0,0,0.55) !important;
  font-weight:600 !important;
}
.leaflet-tooltip:before{
  border-top-color:#020617 !important;
  border-bottom-color:#020617 !important;
}

#map-filter-info {
  background: rgba(15,23,42,0.92) !important;
  border-color: rgba(15,23,42,1) !important;
  color: #e5e7eb !important;
}

#map-filter-info .btn-clear {
  background: #e63946 !important;
  color: #e5e7eb !important;
  border: 0 !important;
}

#map-filter-info .btn-clear:hover {
  background: #b91c1c !important;
  border-color: #f97373 !important;
}

.numeric-scale {
  background: rgba(15,23,42,0.9);
  color: #e5e7eb;
}

.map-attribution{
  background: rgba(15,23,42,0.9);
  color: #e5e7eb;
}
.map-attribution a{
  color: #cbd5f5;
}




.cc-license a{ color: #cbd5f5; }
.carousel-btn {
  background: #020617;
  border-color: #1f2933;
  color: #e5e7eb;
}

.carousel-btn:hover {
  background: #1a2235;
}

.carousel-counter {
  background: #020617;
  border-color: #1f2933;
  color: #e5e7eb;
}

#map {
  border-radius: 10px;
  box-shadow: 0 0 0 12px #0b1120 inset;
  border: 6px solid #0b1120;
  overflow: hidden;
}

/* Sidebar kapalıyken çerçeveyi kaldır */
#sidebar.closed ~ #map {
  border-radius: 0 !important;
  box-shadow: none !important;
  border: none !important;
}
</style>

<style>
/* Popup üçgenini (tip) koyu popup ile aynı renge getir – sadece rengi dokun, şekle değil */
.leaflet-popup-tip {
  background: #020617 !important;  /* popup ile aynı zemin */
  box-shadow: none !important;     /* beyaz/soluk kenar gölgesini kaldır */
}
</style>

<style>
#search:hover {
  background:#1b2236 !important;
  color:#e5e7eb !important;
}
#search:focus {
  background:#1b2236 !important;
  color:#e5e7eb !important;
  outline:none !important;
  border-color:#1f2933 !important;
  box-shadow:none !important;
}
</style>


<style>
#left-edge-hotspot {
  position: fixed;
  left: 0;
  top: 0;
  width: 24px;
  height: 100vh;
  z-index: 1400;
  pointer-events: auto;
}

/* Mobilde menü açıkken sol hotspot dokunuşları çalmasın */
#sidebar:not(.closed) ~ #left-edge-hotspot { pointer-events: none; }
#sidebar.closed ~ #left-edge-hotspot { pointer-events: auto; }

#bottom-edge-hotspot {
  position: fixed;
  left: 0;
  bottom: 0;
  width: 100vw;
  height: 80px;
  z-index: 0;
  pointer-events: none;
}
#map-filter-info {
  transition: opacity 0.25s ease;
}
</style>

<style>
#sidebar-slider {
  margin: 6px 0 10px 0;
}

/* Biraz daha yatay ve kompakt bir oran (yaklaşık 2.3:1) */
.slider-image-wrapper {
  position: relative;
  width: 100%;
  padding-top: 42%;
  overflow: hidden;
  border-radius: 10px;
  border: 1px solid #1f2933;
  background: #020617;
  box-shadow: 0 8px 20px rgba(0,0,0,0.6);
}

#sidebar-slider-image {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0;
  transition: opacity 0.8s ease;
}

#sidebar-slider-image.visible {
  opacity: 1;
}

/* Noktaları tamamen gizle */
.slider-dots {
  display: none !important;
}

.slider-dot {
  width: 6px;
  height: 6px;
  border-radius: 999px;
  background: #4b5563;
  opacity: 0.6;
  cursor: pointer;
  transition: opacity 0.2s ease, transform 0.15s ease, background-color 0.2s ease, width 0.2s ease;
}

.slider-dot.active {
  opacity: 1;
  background: #e63946;
  transform: translateY(-1px);
  width: 14px;
}
</style>


<style>
#film-list mark {
  background-color: #5a70ad;
  color: #e5e7eb;
  padding: 0 1px;
  border-radius: 2px;
}

/* Tab1 arama: eşleşmeyen mekânları hafifçe soluklaştır */
.search-nonmatch{opacity:0.55;}
</style>


<style>
/* Film listesinde aşağıda içerik olduğunu ima eden "scroll hint" */

#scroll-hint{
  position: sticky;
  bottom: -18px;
  width: calc(100% + 36px);
  margin-left: -18px;
  margin-right: -18px;
  height: 52px;
  background: linear-gradient(to bottom, rgba(2,6,23,0), rgba(2,6,23,0.92) 55%, rgba(2,6,23,0.98));
  display: none;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 30;
}

#scroll-hint .hint-pill{
  display:flex;
  align-items:center;
  gap:8px;
  padding:6px 10px;
  border-radius:999px;
  background: rgba(15,23,42,0.85);
  border: 1px solid rgba(148,163,184,0.22);
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
  backdrop-filter: blur(6px);
}

#scroll-hint .hint-icon{
  font-size: 22px;
  line-height: 1;
  color: #e5e7eb;
  text-shadow: 0 2px 8px rgba(0,0,0,0.55);
  animation: scrollPulse 1.35s ease-in-out infinite;
}

#scroll-hint .hint-text{
  font-size: 10px;
  letter-spacing: .12em;
  text-transform: uppercase;
  color: rgba(229,231,235,0.82);
}

@keyframes scrollPulse{
  0%   { transform: translateY(0); opacity: .65; }
  50%  { transform: translateY(7px); opacity: 1; }
  100% { transform: translateY(0); opacity: .65; }
}

/* Desktop'ta daha minimal istersen yazıyı kapat */
@media (min-width: 769px){
  #scroll-hint .hint-text{ opacity: 0.0; width:0; overflow:hidden; padding:0; margin:0; }
  #scroll-hint .hint-pill{ padding:6px 12px; }
}
50%  { transform: translateY(6px); opacity: 1; }
  100% { transform: translateY(0); opacity: .4; }
}
</style>

<style>
/* Tab3 (Bölgeler): scroll hint, Tab1 ile aynı görünüm */
#scroll-hint-bolgeler{
  position: sticky;
  bottom: -18px;
  width: calc(100% + 36px);
  margin-left: -18px;
  margin-right: -18px;
  height: 52px;
  background: linear-gradient(to bottom, rgba(2,6,23,0), rgba(2,6,23,0.92) 55%, rgba(2,6,23,0.98));
  display: none;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 30;
}
</style>



<style>
/* FIX: Seçili (active) dönem butonu yukarı kaymasın — sadece active durumda transform'u sıfırla */
.period-btn.active,
.period-btn.active:hover,
.period-btn.active:focus,
.period-btn.active:focus-visible{
  transform: none !important;
}


/* FIX — tooltip'teki ters (yukarı bakan) küçük üçgeni kaldır, aşağı bakan kuyruk kalsın */
.leaflet-tooltip-top:before,
.leaflet-tooltip-top:after{
  border-bottom-color: transparent !important;
}
.leaflet-tooltip-bottom:before,
.leaflet-tooltip-bottom:after{
  border-top-color: transparent !important;
}

</style>


<style>
.leaflet-control-attribution a:hover{ text-decoration:none; opacity:1; }
</style>

<style>
/* FIX: Map credits (CARTO / OSM) links should be underlined ONLY on hover (remain clickable) */
.map-attribution a,
.map-attribution a:visited,
.map-attribution a:active,
.map-attribution a:focus,
.map-attribution a:focus-visible{
  text-decoration: none !important;
  border-bottom: none !important;
  box-shadow: none !important;
}
.map-attribution a:hover{
  text-decoration: none; !important;
}
</style>



<style>
/* MOBILE FIX: move custom map credits box to top-right (so scale control has room) */
@media (max-width: 768px){
  .map-attribution{
    bottom: auto !important;
    top: 8px !important;
    right: 8px !important;
    left: auto !important;
  }
}
</style>


<style>
/* Thesis title: very light emphasis (medium, not bold) */
.thesis-title{
  font-style: normal;
  font-weight: 600;
}
</style>


<style>
/* --- Tab1 Arama: daha efektif UI --- */
.search-wrap{ margin-bottom: 12px; }
.search-row{ position: relative; display:flex; align-items:center; }
#search{
  width:100%;
  padding-right: 34px; /* clear butonu için */
}
.search-clear{
  position:absolute;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  width: 24px;
  height: 24px;
  border-radius: 8px;
  border: 1px solid rgba(148,163,184,0.25);
  background: rgba(15,23,42,0.75);
  color: rgba(229,231,235,0.95);
  cursor: pointer;
  line-height: 1;
  display: none; /* boşken gizle */
}
.search-clear:hover{ background: rgba(26,34,53,0.9); }
.search-chips{
  margin-top: 8px;
  display:flex;
  flex-wrap: wrap;
  gap: 6px;
}
.search-chips .chip{
  font: inherit;
  font-size: 8.5pt;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid rgba(148,163,184,0.22);
  background: rgba(15,23,42,0.45);
  color: rgba(203,213,245,0.95);
  cursor: pointer;
  transition: transform 0.12s ease, background-color 0.18s ease, border-color 0.18s ease;
}
.search-chips .chip:hover{
  transform: translateY(-1px);
  background: rgba(26,34,53,0.75);
  border-color: rgba(230,57,70,0.35);
}
.search-status{
  margin-top: 8px;
  font-size: 8.5pt;
  color: rgba(156,163,175,0.95);
}
.search-help{
  margin-top: 6px;
  font-size: 8pt;
  color: rgba(107,114,128,0.95);
}
.search-help .k{
  display:inline-block;
  padding: 0 6px;
  border: 1px solid rgba(148,163,184,0.18);
  border-radius: 6px;
  background: rgba(15,23,42,0.35);
  color: rgba(229,231,235,0.92);
  font-style: normal;
}
</style>

<style>
/* Search input: avoid iOS zoom (keep 16px on mobile) but make it look smaller without narrowing the field */
@media (max-width: 768px) {
  #search{
    font-size:16px !important;         /* iOS Safari zoom engeli */
    transform: scale(0.9);             /* metin+kutuyu optik olarak küçült */
    transform-origin: left center;

    /* Görsel genişlik 100% kalsın: (111.111% * 0.9 ≈ 100%) */
    width: 111.111% !important;
    margin-right: -11.111% !important;

    box-sizing: border-box !important;
  }
}

/* Desktop: arama metni biraz daha küçük olsun */
@media (min-width: 769px) {
  #search{
    font-size:14px !important;
  }
}
</style>
<style>

/* --- Künye & lisans: minimal, metin gibi --- */
.credits-wrap{
  margin: 6px 0 8px 0;
}
.credits-label{
  font: inherit;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 0;
  border: none;
  background: none;
  color: #9ca3af;              /* description rengi */
  font-size: 9pt;              /* description'dan bir tık büyük */
  font-weight: 400;
  cursor: pointer;
  user-select: none;
}
.credits-label:hover{
  text-decoration: none;
}

/* Mobilde: açıkken başlık rengi de vurgulansın */
@media (max-width: 768px){
  .credits-wrap.open .credits-label{
    color: #cbd5f5;
  }
}
.credits-ico{
  font-size: 10pt;
  line-height: 1;
}

/* Desktop: içerik açık olduğu sürece başlık vurgulu kalsın */
@media (min-width: 769px){
  .credits-wrap:hover .credits-label{
    color: #cbd5f5;
  }
}
.credits-content{
  margin-top: 6px;
  overflow: hidden;
  max-height: 0;
  opacity: 0;
  transition: max-height 0.25s ease, opacity 0.18s ease;
}

/* Desktop: hover ile aç */
@media (min-width: 769px){
  .credits-wrap:hover .credits-content{
    max-height: 360px;
    opacity: 1;
  }
}

/* Mobile: class ile aç/kapa */
@media (max-width: 768px){
  .credits-wrap.open .credits-content{
    max-height: 420px;
    opacity: 1;
  }
}
</style>
<style>
/* Sidebar başlık ayarı: mobil aynı, masaüstü bir tık daha büyük */
#sidebar h1{
  font-weight:700;
  font-size:12pt;
  margin:4px 0 8px;
}

@media (min-width: 769px){
  #sidebar h1{
    font-size:13.5pt;
    line-height:1.25;
  }
}
</style>
<style>
/* Başlık: bilinçli satır kırımı (yalnızca masaüstü) */
#sidebar h1 .title-top,
#sidebar h1 .title-bottom{
  display: inline; /* mobilde eski davranış: tarayıcı doğal sarsın */
}

@media (min-width: 769px){
  #sidebar h1 .title-top,
  #sidebar h1 .title-bottom{
    display: block; /* masaüstü: Ankara’nın ilk satır, kalan ikinci satır */
  }
}
</style>

<style>
/* --- Sidebar scroll davranışı: sadece listeler kayar --- */
#sidebar{
  overflow: hidden !important;          /* tüm sidebar kaymasın */
  display: flex !important;
  flex-direction: column !important;
}

/* Tab içerikleri sidebar içinde kalan alanı doldursun */
#tab-filmler, #tab-yogunluk, #tab-bolgeler{
  flex: 1 1 auto;
  min-height: 0;                         /* flex içinde scroll için kritik */
}

/* Aktif tab: flex kolon (içeride sabit üst + scroll liste) */
#tab-filmler.active-visible,
#tab-yogunluk.active-visible,
#tab-bolgeler.active-visible{
  display: flex !important;
  flex-direction: column !important;
  min-height: 0 !important;
}

/* Tab1: sadece film listesi alanı kayar */
.film-scroll{
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
}

/* Tab3: sadece poligon film listesi alanı kayar */
.polygon-scroll{
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
}

/* Scroll hint'ler scroll alanının içinde sticky kalsın */
</style>


<style>
/* --- Sidebar: sadece listeler kayar (Tab1 + Tab3) --- */
#sidebar{
  overflow: hidden !important;
  display: flex !important;
  flex-direction: column !important;
}

/* Aktif tab'lar kalan yüksekliği doldursun */
#tab-filmler.active-visible,
#tab-yogunluk.active-visible,
#tab-bolgeler.active-visible{
  display: flex !important;
  flex-direction: column !important;
  min-height: 0 !important;
  flex: 1 1 auto !important;
}

/* Tab1 scroll alanı */
.film-scroll{
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
}

/* Tab3 panel + scroll alanı */
#polygon-panel{
  flex: 1 1 auto;
  min-height: 0;
  display: flex;
  flex-direction: column;
}
#polygon-summary{ flex: 0 0 auto; }

.polygon-scroll{
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
}
</style>



<style>
/* Mobil: Tab3 dönem yılları daha kompakt (taşma olmasın) */
@media (max-width: 768px){
  .period-row{
    flex-wrap: nowrap !important;
    justify-content: space-between;
    gap: 8px;
  }
  .period-item{
    font-size: 8pt;          /* bir tık daha küçük */
    line-height: 1.1;
    white-space: nowrap;
  }
  .period-box{
    width: 7px;
    height: 7px;
    flex: 0 0 7px;
  }
}
</style>




<style>
/* Mobil: Tab3 dönem etiketlerini kısalt (apostrofsuz) */
.period-short{ display:none; }

@media (max-width: 768px){
  .period-full{ display:none; }
  .period-short{
    display:inline;
    font-size: 8pt;
    line-height: 1.1;
    white-space: nowrap;
  }
}
</style>


<script>
/* --- SHARED SEARCH UTILS (single source of truth) --- */
window.__normTR = function(s){
  return (s||'')
    .toLocaleLowerCase('tr-TR')
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/ı/g,'i');
};
window.__tokenize = function(q){
  return (q||'').trim().split(/\s+/).filter(Boolean);
};
window.__highlightPrefix = function(el, q){
  if(!el || !q) return false;
  const raw = el.dataset.rawText || el.textContent || '';
  const tokens = __tokenize(q).map(__normTR).filter(Boolean);
  if(!tokens.length) return false;

  const nrawAll = __normTR(raw);

  function endIndexForNormPrefix(rawStr, normPrefix){
    // Find the smallest end index in rawStr such that __normTR(rawStr.slice(0,end)) === normPrefix
    let acc = '';
    for(let i=0; i<rawStr.length; i++){
      // accumulate normalization per character to keep mapping stable under diacritics
      acc += __normTR(rawStr[i]);
      if(acc.length >= normPrefix.length){
        if(acc.slice(0, normPrefix.length) === normPrefix) return i+1;
        // if we've overshot and don't match, no need to keep going for prefix case
        return null;
      }
    }
    return null;
  }

  // Highlight ONLY the first matching prefix token (usually first word typed)
  for(const tok of tokens){
    if(!tok) continue;
    if(nrawAll.startsWith(tok)){
      const end = endIndexForNormPrefix(raw, tok);
      if(end && end > 0){
        el.innerHTML = '<mark>' + raw.slice(0, end) + '</mark>' + raw.slice(end);
        return true;
      }
    }
  }
  return false;
};
</script>

</head>
<body>
<aside id="sidebar">
<h1><span class="title-top">Ankara’nın</span> <span class="title-bottom">Sinemasal Kartografyası</span></h1>

<div class="credits-wrap" id="credits-wrap">
  <button type="button" class="credits-label" id="credits-label" aria-expanded="false">
    <span class="credits-ico" aria-hidden="true">ⓘ</span>
    <span class="credits-text">Künye ve lisans</span>
  </button>

  <div class="credits-content" id="credits-content" aria-hidden="true">
    <div class="description description-justify">Bu çalışma Yükseköğretim Kurulu Tez Merkezi'ne kaydı 2022 yılında yapılan ve Ankara Üniversitesi Sosyal Bilimler Ensitüsü Yönetim Kurulu'nun 08/02/2023 tarihli, 1899/21-25 sayılı kararı uyarınca Radyo Televizyon ve Sinema Anabilim Dalı'nda Prof. Dr. S. Ruken Öztürk danışmanlığında, Prof. Dr. Burcu Sümer ve Prof. Dr. Aydan Özsoy izleme komitesi üyeliğinde Arş. Gör. Sezer Ahmet Kına tarafından yürütülen <span class="thesis-title">Sinemada Kentin Dönüşümünü Seyretmek: Ankara Örneği</span> başlıklı doktora tezi kapsamında hazırlanmış; içeriği yazar tarafından üretilerek yapay zekâ araçlarıyla tasarlanmıştır.</div>

    <p class="cc-license" xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
      <a property="dct:title" rel="cc:attributionURL" href="https://ankaracinemap.sezerkina.com">Ankara'nın Sinemasal Kartografyası</a> (2022)
      <a rel="cc:attributionURL dct:creator" property="cc:attributionName" href="https://sezerkina.com">Sezer Ahmet Kına</a>
      tarafından
      <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.tr" rel="noopener noreferrer" target="_blank">CC&nbsp;BY-NC-ND</a>
      ile lisanslanmıştır.
    </p>
  </div>
</div>


<div id="sidebar-slider">
  <div class="slider-image-wrapper">
    <img id="sidebar-slider-image" src="images/menu-images/m_i.jpg" alt="Ankara sinematik görseli"/>
  </div>
  <div class="slider-dots"></div>
</div>

<div id="tab-menu"
 style="display:flex;gap:8px;margin-bottom:12px;">
<button class="tab-btn active" data-tab="filmler" style="flex:1;padding:6px 4px;border:1px solid #ccc;border-radius:6px;background:#fff;cursor:pointer;">Filmler ve Mekânlar</button>
<button class="tab-btn" data-tab="yogunluk" style="flex:1;padding:6px 4px;border:1px solid #ccc;border-radius:6px;background:#fff;cursor:pointer;">Dağılım ve Yoğunluk</button>
<button class="tab-btn" data-tab="bolgeler" style="flex:1;padding:6px 4px;border:1px solid #ccc;border-radius:6px;background:#fff;cursor:pointer;">Kentsel Odaklar</button>
</div>

<div class="tab-content active-visible" id="tab-filmler">
<input aria-label="Haritada ara" id="search" placeholder="Haritada ara"/>
<div class="film-scroll"><div id="film-list"></div>
<div id="scroll-hint" aria-hidden="true"><span>⌄</span></div>
</div>
</div>

<div class="tab-content" id="tab-yogunluk">
  <div id="period-buttons" style="display:flex; gap:6px; margin-bottom:10px; flex-wrap:wrap;">
    <button class="period-btn" data-period="1966-1980"><span class="period-full">1966–1980</span><span class="period-short">66–80</span>: Yeşilçam'ın Modern Ankara'sı</button>
    <button class="period-btn" data-period="1988-2001"><span class="period-full">1988–2001</span><span class="period-short">88–01</span>: Neoliberal Çevrim ve Yeni Merkezler</button>
    <button class="period-btn" data-period="2010-2022"><span class="period-full">2010–2022</span><span class="period-short">10–22</span>: Dağınık Odak, Parçalı Metropol</button>
  </div>
  <div id="yogunluk-content"></div>
</div>

<div class="tab-content" id="tab-bolgeler">
  <div id="polygon-panel" style="display:none;">
    <div id="polygon-summary" class="polygon-summary"></div>
    <div class="polygon-scroll">
      <div id="polygon-film-list"></div>
      <div id="scroll-hint-bolgeler" aria-hidden="true"><span>⌄</span></div>
    </div>
  </div>

  <div id="polygon-empty" style="color:#9ca3af;font-size:10pt;line-height:1.3;">
    Haritadan bir odak seçiniz.
  </div>
</div>


</aside>
<div id="toggle-btn"><span>◂</span></div>
<div id="left-edge-hotspot"></div>
<div id="bottom-edge-hotspot"></div>
<div id="map">
<div id="map-filter-info" style="display:none;position:absolute;bottom:18px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.85);backdrop-filter:blur(6px);border:1px solid rgba(0,0,0,0.1);border-radius:10px;padding:6px 12px;font-size:13px;color:#111;z-index:1500;box-shadow:0 2px 4px rgba(0,0,0,0.08);"></div>
<div class="map-attribution" aria-label="Harita altyapı kredileri">
  <span class="credit-short">ⓘ Map credits</span>
  <span class="credit-full">
    © <a href="https://carto.com/" target="_blank" rel="noopener">CARTO</a> · <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OSM</a></span>
</div>
</div>
<script>
function cleanFolderName(folder){
  if(!folder) return "";
  return folder.replace(/[\/|]+/g, '').trim();
}

const DEFAULT_CENTER = [39.93, 32.85];
const DEFAULT_ZOOM = 11;
const hitRenderer = L.canvas({tolerance:18});
const map = L.map('map', {preferCanvas:true, tap:true, tapTolerance:20}).setView(DEFAULT_CENTER, DEFAULT_ZOOM);
// Panes: poligonlar altta, çizgiler ortada, markerlar üstte (tıklanabilirlik için)
map.createPane('polygonPane');
map.getPane('polygonPane').style.zIndex = 350;
map.createPane('linePane');
map.getPane('linePane').style.zIndex = 450;
map.createPane('markerPane');
map.getPane('markerPane').style.zIndex = 650;

L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
  maxZoom: 22, }).addTo(map);
const scaleDiv = L.DomUtil.create('div', 'numeric-scale', map.getContainer());
function updateNumericScale() {
  const centerLat = map.getCenter().lat;
  const metersPerPixel = 156543.03392 * Math.cos(centerLat * Math.PI / 180) / Math.pow(2, map.getZoom());
  const scaleDenominator = Math.round(39.37 * metersPerPixel * 96);
  scaleDiv.textContent = '1 : ' + scaleDenominator.toLocaleString('tr-TR');
}
map.on('moveend zoomend', updateNumericScale);
updateNumericScale();

// --- UX: harita üzerinde herhangi bir yere tıklanınca sidebar kapansın (mobil + masaüstü) ---

// --- Sidebar kapatma yardımcı fonksiyonu ---
function closeSidebar(){
  try{
    const sidebar = document.getElementById('sidebar');
    if(!sidebar) return;
    if(!sidebar.classList.contains('closed')){
      sidebar.classList.add('closed');
      const btn = document.getElementById('toggle-btn');
      if(btn) btn.style.left = '0';
    }
  }catch(e){}
}


function openSidebar(){
  try{
    const sidebar = document.getElementById('sidebar');
    if(!sidebar) return;
    sidebar.classList.remove('closed');

    // Toggle butonunu sidebar'ın hemen sağına al
    const btn = document.getElementById('toggle-btn');
    if(btn){
      const w = sidebar.offsetWidth || 340;
      btn.style.left = w + 'px';
    }
  }catch(e){}
}
// Popup açılınca: 
// - Mobilde her durumda sidebar kapansın.
// - Masaüstünde: popup soldaki listeden açıldıysa kapanmasın; haritadan (marker tık) açıldıysa kapansın.
window.__popupFromList = window.__popupFromList || false;
function __isMobileWidth(){ return window.innerWidth <= 768; }

map.on('popupopen', function(){
  try{
    if(__isMobileWidth()){
      closeSidebar();
    }else{
      if(!window.__popupFromList){
        closeSidebar();
      }
    }
  }finally{
    // bir sonraki popup için resetle
    window.__popupFromList = false;
  }
});
map.on('click', function(){
  try{
    const sidebar = document.getElementById('sidebar');
    if(!sidebar) return;

    if(!sidebar.classList.contains('closed')){
      sidebar.classList.add('closed');
      const btn = document.getElementById('toggle-btn');
      if(btn) btn.style.left = '0';
    }
  }catch(e){}
});
let films = {};
let featureToLayer = new Map();
let allLayers = L.layerGroup().addTo(map);
let polygonLayers = L.layerGroup().addTo(map); // Tab3 poligon katmanı (kmzs katmanından ayrı)
let __kmzPointLayers = []; // kmzs: Point/MultiPoint layer'ları
let __kmzOtherLayers = []; // kmzs: LineString vb.
let __activePolygonFeature = null;
let __activePolygonName = null;
let __activePolygonLayer = null;
let allKmzFeatures = [];

// --- Bölgeler (poligonlar) ---
let polygonFeatures = null;
let polygonLayerIndex = []; // {name, layer, bounds}

function __getPolygonName(props){
  if(!props) return "Bölge";
  // önce name gibi anahtarlar
  const direct = props.name || props.Name || props.NAME || props.bolge || props.Bolge || props.BÖLGE;
  if(direct && String(direct).trim()) return String(direct).trim();

  // geojson.io bazen "Ulus": "" gibi tek anahtar koyuyor
  const keys = Object.keys(props || {});
  if(keys.length === 1 && keys[0]) return String(keys[0]).trim();

  // birden fazla anahtar varsa ilk dolu değeri al, yoksa ilk anahtar
  for(const k of keys){
    const v = props[k];
    if(v !== null && v !== undefined && String(v).trim()) return String(v).trim();
  }
  if(keys[0]) return String(keys[0]).trim();

  return "Bölge";
}

function __renderPolygonsToSidebar(){
  const listEl = document.getElementById('bolgeler-list');
  if(!listEl) return;
  listEl.innerHTML = '';

  polygonLayerIndex.forEach((item) => {
    const b = document.createElement('button');
    b.className = 'period-btn';
    b.textContent = item.name;
    b.addEventListener('click', () => {
      document.querySelectorAll('#bolgeler-list .period-btn').forEach(x=>x.classList.remove('active'));
      try{ clearPolygonFilter(); }catch(e){}
      b.classList.add('active');
      try{
        // seçili poligon filtresi uygula
        try{
          const base = (item.layer && item.layer.getLayers) ? (item.layer.getLayers()[0] || item.layer) : item.layer;
          applyPolygonFilter(item.feature, item.name, base);
        }catch(e){}
        if(item.bounds && item.bounds.isValid && item.bounds.isValid()){
          map.fitBounds(item.bounds.pad(0.08), { padding: [20,20], maxZoom: 16, animate: true });
        }
      }catch(e){}
    });
    listEl.appendChild(b);
  });

  const allBtn = document.getElementById('btn-show-all-polygons');
  if(allBtn){
    allBtn.addEventListener('click', () => {
      document.querySelectorAll('#bolgeler-list .period-btn').forEach(x=>x.classList.remove('active'));
      const bb = L.latLngBounds([]);
      polygonLayerIndex.forEach(it => { try{ if(it.bounds) bb.extend(it.bounds); }catch(e){} });
      try{
        if(bb.isValid && bb.isValid()) map.fitBounds(bb.pad(0.08), { padding: [20,20], maxZoom: 13, animate: true });
      }catch(e){}
    });
  }
}

function loadPolygons(){
  // FORCE reload polygons every time
  polygonFeatures = null;
  polygonLayerIndex = [];

  // Tab3 poligon katmanı: kmzs (noktasal/çizgisel) katmanını silmeden sadece poligonları yönet
  try{ if(polygonLayers) polygonLayers.clearLayers(); }catch(e){}

  if(polygonFeatures){
    // cache varsa yeniden çiz
    polygonLayerIndex.forEach(it => { try{ polygonLayers.addLayer(it.layer); }catch(e){} });
    __renderPolygonsToSidebar();
    // default: tümünü göster
    const bb = L.latLngBounds([]);
    polygonLayerIndex.forEach(it => { try{ if(it.bounds) bb.extend(it.bounds); }catch(e){} });
    try{ if(bb.isValid && bb.isValid()) map.fitBounds(bb.pad(0.08), { padding:[20,20], maxZoom: 13, animate:true }); }catch(e){}
    return;
  }

  fetch('poligons.geojson')
    .then(r => r.json())
    .then(geojson => {
      polygonFeatures = geojson;

      polygonLayerIndex = [];
      const bb = L.latLngBounds([]);

      (geojson.features || []).forEach((f) => {
        if(!f || !f.geometry) return;
        const gt = f.geometry.type;
        if(gt !== 'Polygon' && gt !== 'MultiPolygon') return;

        const name = __getPolygonName(f.properties);

        const layer = L.geoJSON(f, {
          pane: 'polygonPane',
          renderer: hitRenderer,
          interactive: true,
          bubblingMouseEvents: false,
          style: function(){
            return { weight: 2, opacity: 0.9, fillOpacity: 0.07, color: '#596f8f', fillColor: '#596f8f', lineJoin: 'round', lineCap: 'round', dashArray: '6 4' };
          },
          onEachFeature: function(feat, lyr){
            try{
              const n = __getPolygonName(feat.properties);              // Popup disabled (sidebar already shows details)
              try{
                lyr.bindTooltip(n, {sticky:true, direction:'top', opacity:0.95});
              }catch(e){}

              
              // Tooltip: seçili poligonda açılmasın
              try{
                lyr.on('tooltipopen', function(){
                  try{
                    if(__activePolygonLayer && __activePolygonLayer === lyr){
                      lyr.closeTooltip && lyr.closeTooltip();
                    }
                  }catch(e){}
                });
              }catch(e){}
// Hover: bölgeyi belli et (seçili değilse)
              try{
                lyr.on('mouseover', function(){
                  try{
                    if(__activePolygonLayer && __activePolygonLayer === lyr) return;
                    lyr.setStyle({ weight: 3, opacity: 1, fillOpacity: 0.07, color: '#e5e7eb', fillColor: '#596f8f', lineJoin: 'round', lineCap: 'round', dashArray: '6 4' });
                  }catch(e){}
                });
                lyr.on('mouseout', function(){
                  try{
                    if(__activePolygonLayer && __activePolygonLayer === lyr) return;
                    lyr.setStyle({ weight: 2, opacity: 0.9, fillOpacity: 0.07, color: '#596f8f', fillColor: '#596f8f', lineJoin: 'round', lineCap: 'round', dashArray: '6 4' });
                  }catch(e){}
                });
              }catch(e){}

              try{
                  // IMPORTANT: Only bind on 'click' (not 'mousedown').
                  // If we add KMZ layers on mousedown, they may appear under the cursor before the subsequent 'click'
                  // and steal that click (opening popups). Binding only to 'click' ensures the first click selects
                  // the polygon and only then reveals KMZ items.
                  lyr.on('click', function(e){
                    try{ if(e && e.originalEvent) L.DomEvent.stop(e.originalEvent); }catch(err){}
                    
                    try{ if(lyr && lyr.closeTooltip) lyr.closeTooltip(); }catch(e){}
applyPolygonFilter(feat, n, lyr);
                  });
                }catch(e){}
            }catch(e){}
          }
        });

        // bounds + index
        let bounds = null;
        try{ bounds = layer.getBounds(); }catch(e){}
        polygonLayerIndex.push({ name, layer, bounds, feature: f });

        try{ polygonLayers.addLayer(layer); }catch(e){}
        try{ if(bounds) bb.extend(bounds); }catch(e){}
      });

      // sidebar listesi
      __renderPolygonsToSidebar();

      // default: Tab1/Tab2 ile aynı odak/ölçek (Tab3'e girince harita zıplamasın)
      try{ map.setView(DEFAULT_CENTER, DEFAULT_ZOOM, { animate: false }); }catch(e){}
})
    .catch(err => console.error('poligons.geojson okunamadı:', err));
}


function __pointInRing(lng, lat, ring){
  // ring: [[lng,lat],...]
  let inside = false;
  for (let i=0, j=ring.length-1; i<ring.length; j=i++){
    const xi = ring[i][0], yi = ring[i][1];
    const xj = ring[j][0], yj = ring[j][1];
    const intersect = ((yi > lat) !== (yj > lat)) && (lng < (xj - xi) * (lat - yi) / ((yj - yi) || 1e-12) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function __pointInGeoJSONPolygon(latlng, geom){
  if(!latlng || !geom) return false;
  const lng = latlng.lng, lat = latlng.lat;

  const checkPolygonCoords = (coords) => {
    if(!coords || !coords.length) return false;
    const outer = coords[0];
    if(!outer || outer.length < 3) return false;
    if(!__pointInRing(lng, lat, outer)) return false;
    // holes
    for(let h=1; h<coords.length; h++){
      const hole = coords[h];
      if(hole && hole.length >= 3 && __pointInRing(lng, lat, hole)) return false;
    }
    return true;
  };

  if(geom.type === 'Polygon'){
    return checkPolygonCoords(geom.coordinates);
  }
  if(geom.type === 'MultiPolygon'){
    const polys = geom.coordinates || [];
    for(let p=0; p<polys.length; p++){
      if(checkPolygonCoords(polys[p])) return true;
    }
    return false;
  }
  return false;
}

function __layerInsidePolygon(layer, polyFeature){
  if(!layer || !polyFeature || !polyFeature.geometry) return false;

  // helper: latlng flatten
  const __flatten = (latlngs, out=[]) => {
    if(!latlngs) return out;
    if(Array.isArray(latlngs)){
      latlngs.forEach(x => __flatten(x, out));
    } else if(typeof latlngs.lat === 'number' && typeof latlngs.lng === 'number'){
      out.push(latlngs);
    }
    return out;
  };

  // Point / CircleMarker
  if(typeof layer.getLatLng === 'function'){
    return __pointInGeoJSONPolygon(layer.getLatLng(), polyFeature.geometry);
  }

  // MultiPoint group
  if(typeof layer.getLayers === 'function'){
    try{
      const subs = layer.getLayers() || [];
      for(let i=0; i<subs.length; i++){
        const sub = subs[i];
        if(!sub) continue;
        if(typeof sub.getLatLng === 'function'){
          if(__pointInGeoJSONPolygon(sub.getLatLng(), polyFeature.geometry)) return true;
        } else if(typeof sub.getLatLngs === 'function'){
          const pts = __flatten(sub.getLatLngs(), []);
          for(let j=0; j<pts.length; j++){
            if(__pointInGeoJSONPolygon(pts[j], polyFeature.geometry)) return true;
          }
        }
      }
    }catch(e){}
  }

  // Polyline / MultiPolyline
  if(typeof layer.getLatLngs === 'function'){
    try{
      const pts = __flatten(layer.getLatLngs(), []);
      for(let i=0; i<pts.length; i++){
        if(__pointInGeoJSONPolygon(pts[i], polyFeature.geometry)) return true;
      }
    }catch(e){}
  }

  return false;
}



function __isPointGeom(t){ return (t === 'Point' || t === 'MultiPoint'); }
function __isLineGeom(t){ return (t === 'LineString' || t === 'MultiLineString'); }

function __computeGlobalMarkerTotals(){
  let totalPoints = 0, totalLines = 0;
  (allKmzFeatures || []).forEach(f => {
    const t = f && f.geometry ? f.geometry.type : null;
    if(__isPointGeom(t)) totalPoints++;
    else if(__isLineGeom(t)) totalLines++;
  });
  return { totalPoints, totalLines, totalAll: (totalPoints + totalLines) };
}

function __isTab3Active(){
  try{
    const t = document.getElementById('tab-bolgeler');
    return !!(t && t.classList && t.classList.contains('active-visible'));
  }catch(e){ return false; }
}

function __layerInsideAnyPolygon(layer){
  try{
    if(!polygonFeatures || !polygonFeatures.features || !polygonFeatures.features.length) return false;
    for(let i=0; i<polygonFeatures.features.length; i++){
      const f = polygonFeatures.features[i];
      if(!f || !f.geometry) continue;
      const gt = f.geometry.type;
      if(gt !== 'Polygon' && gt !== 'MultiPolygon') continue;
      if(__layerInsidePolygon(layer, f)) return true;
    }
  }catch(e){}
  return false;
}

function __promptSelectRegion(){
  try{
    const empty = document.getElementById('polygon-empty');
    const panel = document.getElementById('polygon-panel');
    if(panel) panel.style.display = 'none';
    if(empty){
      empty.style.display = 'block';
      empty.innerHTML = 'Önce haritadan bir <b>bölge</b> seç. <span style="color:#6b7280;">(Bölge dışında kalan markerlar seçilebilir.)</span>';
    }
  }catch(e){}
}

/**
 * Tab3'te poligon seçilmeden, herhangi bir poligonun İÇİNDE kalan kırmızı öğelere tıklamayı engeller.
 * - Tab1/Tab2: hiç dokunmaz.
 * - Tab3 + poligon seçili: serbest bırakır.
 */
function __markerClickGate(layer, ev){
  try{
    if(!__isTab3Active()) return true;      // sadece Tab3
    if(__activePolygonFeature) return true; // poligon seçildiyse serbest

    // poligonlar gelmediyse engelleme yapma
    if(!polygonFeatures) return true;

    // Poligon içindeyse: önce bölge seçilmeli
    if(__layerInsideAnyPolygon(layer)){
      try{ map.closePopup(); }catch(e){}
      try{ if(layer && layer.closePopup) layer.closePopup(); }catch(e){}
      __promptSelectRegion();

      // popup auto-open dahil, olayı kes
      try{
        const oe = (ev && ev.originalEvent) ? ev.originalEvent : ev;
        if(oe) L.DomEvent.stop(oe);
      }catch(e){}
      return false;
    }
  }catch(e){}
  return true;
}

/**
 * Leaflet'in bindPopup() otomatik açılmasını da kontrol etmek için:
 * 'preclick' aşamasında gate uygular.
 */
function __wireClickGate(layer){
  try{
    if(!layer) return;
    if(layer.__clickGateWired) return;
    layer.__clickGateWired = true;

    if(layer.on){
      layer.on('preclick', function(e){
        
        // Point/marker tıklaması: map click handler sidebar'ı kapatmasın
        try{
          if(typeof layer.getLatLng === 'function'){
            }
        }catch(_e){} 
if(!__markerClickGate(layer, e)){
          try{
            const oe = (e && e.originalEvent) ? e.originalEvent : e;
            if(oe) L.DomEvent.stop(oe);
          }catch(err){}
        }
      });
    }

    // Group ise çocuklara da uygula
    if(layer.getLayers && typeof layer.getLayers === 'function'){
      try{ layer.getLayers().forEach(ch => __wireClickGate(ch)); }catch(e){}
    }
  }catch(e){}
}


function __computePolygonStats(polyFeature){
  const filmToItems = new Map(); // film -> [{name, kind, feature}]
  const filmSet = new Set();
  let pts = 0, lines = 0;

  (allKmzFeatures || []).forEach(f => {
    const layer = featureToLayer.get(f);
    if(!layer) return;

    if(!__layerInsidePolygon(layer, polyFeature)) return;

    const film = cleanFolderName(f?.properties?.folder) || "Bilinmeyen Film";
    const name = (f?.properties?.name) ? String(f.properties.name) : "(Adsız Mekân)";
    const t = f && f.geometry ? f.geometry.type : null;

    let kind = 'diger';
    if(__isPointGeom(t)) { kind = 'mekan'; pts++; }
    else if(__isLineGeom(t)) { kind = 'rota'; lines++; }

    filmSet.add(film);
    const arr = filmToItems.get(film) || [];
    arr.push({ name, kind, feature: f });
    filmToItems.set(film, arr);
  });

  const totals = __computeGlobalMarkerTotals();
  const inAll = pts + lines;
  const pct = totals.totalAll ? (inAll / totals.totalAll * 100) : 0;

  return { pts, lines, films: filmSet.size, pct, filmToItems, totals, inAll };
}

function __renderPolygonPanel(polyName, stats){
  const panel = document.getElementById('polygon-panel');
  const empty = document.getElementById('polygon-empty');
  const sum = document.getElementById('polygon-summary');
  const list = document.getElementById('polygon-film-list');
  if(!panel || !sum || !list || !empty) return;

  empty.style.display = 'none';
  panel.style.display = 'flex';

  const pct1 = Math.round((stats.pct || 0) * 10) / 10;
  const pctText = pct1.toLocaleString('tr-TR');

  // Dönem göstergeleri (poligon içindeki film yıllarına göre)
  const __periods = { p1:false, p2:false, p3:false };
  try{
    Array.from(stats.filmToItems.keys()).forEach((filmName)=>{
      const m = String(filmName || '').match(/\b(19\d{2}|20\d{2})\b/);
      if(!m) return;
      const y = parseInt(m[0], 10);
      if(y >= 1966 && y <= 1980) __periods.p1 = true;
      if(y >= 1988 && y <= 2001) __periods.p2 = true;
      if(y >= 2010 && y <= 2022) __periods.p3 = true;
    });
  }catch(e){}

  const __periodRow =
    '<div class="period-row">' +
      '<span class="period-item"><span class="period-box ' + (__periods.p1 ? 'on' : '') + '"></span><span><span class="period-full">1966–1980</span><span class="period-short">66–80</span></span></span>' +
      '<span class="period-item"><span class="period-box ' + (__periods.p2 ? 'on' : '') + '"></span><span><span class="period-full">1988–2001</span><span class="period-short">88–01</span></span></span>' +
      '<span class="period-item"><span class="period-box ' + (__periods.p3 ? 'on' : '') + '"></span><span><span class="period-full">2010–2022</span><span class="period-short">10–22</span></span></span>' +
    '</div>';

  sum.innerHTML =
    '<div style="font-weight:700;font-size:12pt;margin-bottom:6px;">' + __escapeHtml(polyName || 'Bölge') + '</div>' +
    '<div class="polygon-kpis">' +
      '<div><span class="k">Film</span><span class="v">' + (stats.films || 0) + '</span></div>' +
      '<div><span class="k">Kartografik oran</span><span class="v">%' + pctText + '</span></div>' +
      '<div><span class="k">Mekân</span><span class="v">' + (stats.pts || 0) + '</span></div>' +
      '<div><span class="k">Rota</span><span class="v">' + (stats.lines || 0) + '</span></div>' +
    '</div>' + __periodRow;


  list.innerHTML = '';

  const filmsSorted = Array.from(stats.filmToItems.keys())
    .sort((a,b)=>{
      const ya = parseInt((String(a).match(/\b(19\d{2}|20\d{2})\b/)||[0])[0]);
      const yb = parseInt((String(b).match(/\b(19\d{2}|20\d{2})\b/)||[0])[0]);
      const hasA = !isNaN(ya), hasB = !isNaN(yb);
      if(hasA && hasB && ya !== yb) return ya - yb;
      if(hasA && !hasB) return -1;
      if(!hasA && hasB) return 1;
      return String(a).localeCompare(String(b), 'tr');
    });
filmsSorted.forEach(filmName => {
    const wrap = document.createElement('div');
    wrap.className = 'film';

    const title = document.createElement('div');
    title.className = 'film-title';
    title.textContent = filmName;

    const ul = document.createElement('ul');
    ul.className = 'mekan-list';
    ul.style.display = 'none';

    const items = (stats.filmToItems.get(filmName) || []).slice();
    items.sort((a,b)=>{
      if(a.kind === b.kind) return String(a.name).localeCompare(String(b.name), 'tr');
      if(a.kind === 'mekan') return -1;
      if(b.kind === 'mekan') return 1;
      if(a.kind === 'rota') return -1;
      if(b.kind === 'rota') return 1;
      return 0;
    });

    items.forEach(it => {
      const li = document.createElement('li');
      li.textContent = it.name;
      li.dataset.rawText = li.textContent;

      li.onclick = (e) => {
        e.stopPropagation();
        const layer = featureToLayer.get(it.feature);
        if(!layer) return;

        let targetCenter = null;
        let bounds = L.latLngBounds([]);

        if (layer.getLatLng) {
          targetCenter = layer.getLatLng();
        } else if (layer.getBounds) {
          try{ bounds.extend(layer.getBounds()); }catch(err){}
        } else if (layer.getLayers && typeof layer.getLayers === "function") {
          try{
            layer.getLayers().forEach((sub) => {
              if (sub.getLatLng) bounds.extend(sub.getLatLng());
              else if (sub.getBounds) bounds.extend(sub.getBounds());
            });
          }catch(err){}
        }

        if (bounds.isValid && bounds.isValid()) targetCenter = bounds.getCenter();

        if (targetCenter) {
          map.setView(targetCenter, 16, { animate: true });
          setTimeout(() => { try{ map.panTo(targetCenter, { animate: true }); }catch(err){} }, 200);
        }

        window.__popupFromList = true;

        // Open popup for the clicked item (mekân/rota) when available
        try{
          if(layer.openPopup){
            layer.openPopup();
          } else if (layer.getLayers && typeof layer.getLayers === "function") {
            const subs = layer.getLayers();
            const firstWithPopup = (subs && subs.find) ? subs.find(l => l && l.openPopup) : null;
            const sub = firstWithPopup || (subs ? subs[0] : null);
            if(sub && sub.openPopup) sub.openPopup();
          }
        }catch(err){}
      };

      ul.appendChild(li);
    });

    title.onclick = function(e){
      const next = (ul.style.display === 'none' || ul.style.display === '') ? 'block' : 'none';
      ul.style.display = next;
      // Kullanıcı manuel aç/kapa yaptıysa bunu hatırla (arama temizlenince geri almak için)
      try{ ul.dataset.userToggled = '1'; ul.dataset.userToggledState = next; }catch(_e){}
    };

    wrap.appendChild(title);
    wrap.appendChild(ul);
    list.appendChild(wrap);
  });
}

function __clearPolygonPanel(){
  const panel = document.getElementById('polygon-panel');
  const empty = document.getElementById('polygon-empty');
  const sum = document.getElementById('polygon-summary');
  const list = document.getElementById('polygon-film-list');
  if(sum) sum.innerHTML = '';
  if(list) list.innerHTML = '';
  if(panel) panel.style.display = 'none';
  if(empty) empty.style.display = 'block';
}


function __setPolygonFilterInfo(name){
  const fi = document.getElementById('map-filter-info');
  if(!fi) return;
  fi.style.display = 'block';
  fi.innerHTML = '<span class="fi-ico" aria-hidden="true">🔎</span>' +
    '<strong>' + __escapeHtml(name || '') +
    '</strong> odağı görüntüleniyor. ' +
    '<button class="btn-clear" type="button" onclick="clearPolygonFilter()">Tümünü Göster</button>';
}

function clearPolygonFilter(){
  __activePolygonFeature = null;
  __activePolygonName = null;

  // poligon stili reset
  try{
    if(__activePolygonLayer && __activePolygonLayer.setStyle){
      __activePolygonLayer.setStyle({ weight: 2, opacity: 0.9, fillOpacity: 0.07, color: '#596f8f', fillColor: '#596f8f', lineJoin: 'round', lineCap: 'round', dashArray: '6 4' });
      // seçiliyken öne alınmışsa geri it
      __activePolygonLayer.bringToBack && __activePolygonLayer.bringToBack();
    }
  }catch(e){}
  __activePolygonLayer = null;

  // Tab3'te "Temizle" => tekrar sadece poligonlar kalsın
  try{
    if(__isTab3Active && __isTab3Active()){
      try{ allLayers.clearLayers(); }catch(e){}
    } else {
      // tüm kmzs katmanlarını geri getir (point + diğer)
      __kmzPointLayers.forEach(l => { if(l && !allLayers.hasLayer(l)) allLayers.addLayer(l); });
      __kmzOtherLayers.forEach(l => { if(l && !allLayers.hasLayer(l)) allLayers.addLayer(l); });

      // markerlar üstte kalsın
      __kmzPointLayers.forEach(l => { try{ l.bringToFront && l.bringToFront(); }catch(e){} });
      __kmzOtherLayers.forEach(l => { try{ l.bringToFront && l.bringToFront(); }catch(e){} });
    }
  }catch(e){}
    // Tab3 default görünümüne dön (zoom/merkez)
  try{
    if(__isTab3Active && __isTab3Active()){
      map.setView(DEFAULT_CENTER, DEFAULT_ZOOM, { animate: true });
    }
  }catch(e){}
__clearPolygonPanel();
  clearFilterInfo();
}

function applyPolygonFilter(polyFeature, polyName, polyLeafletLayer){
    // Desktop'ta (Tab3) her poligon seçiminde sidebar otomatik açılsın
  try{
    if(window.innerWidth > 768 && __isTab3Active && __isTab3Active()){
      openSidebar();
    }
  }catch(e){}
__activePolygonFeature = polyFeature;
  __activePolygonName = polyName;

  // önce eski seçiliyi resetle
  try{
    if(__activePolygonLayer && __activePolygonLayer.setStyle){
      __activePolygonLayer.setStyle({ weight: 2, opacity: 0.9, fillOpacity: 0.07, color: '#596f8f', fillColor: '#596f8f', lineJoin: 'round', lineCap: 'round', dashArray: '6 4' });
      __activePolygonLayer.bringToBack && __activePolygonLayer.bringToBack();
    }
  }catch(e){}
  __activePolygonLayer = polyLeafletLayer || null;

  // seçili poligonu vurgula ama markerların üstüne çıkmasına izin verme
  try{
    if(__activePolygonLayer && __activePolygonLayer.setStyle){
      __activePolygonLayer.setStyle({ weight: 4, opacity: 1, fillOpacity: 0.20, color: '#334155', fillColor: '#475569', lineJoin: 'round', lineCap: 'round', dashArray: '6 4' });
      __activePolygonLayer.bringToBack && __activePolygonLayer.bringToBack();
    }
  }catch(e){}
  // Tab3: seçilen poligona zoom + ortala
  try{
    if(__activePolygonLayer){
      let bb = null;
      if(__activePolygonLayer.getBounds) bb = __activePolygonLayer.getBounds();
      else if(__activePolygonLayer.getLayers){
        const first = (__activePolygonLayer.getLayers() || [])[0];
        if(first && first.getBounds) bb = first.getBounds();
      }
      if(bb && bb.isValid && bb.isValid()){
        map.fitBounds(bb.pad(0.10), { padding:[20,20], maxZoom:16, animate:true });
      }
    }
  }catch(e){}

  // kmzs layer'larını filtrele (point + çizgisel)
  try{
    // hepsini kaldır
    __kmzPointLayers.forEach(l => { if(l && allLayers.hasLayer(l)) allLayers.removeLayer(l); });
    __kmzOtherLayers.forEach(l => { if(l && allLayers.hasLayer(l)) allLayers.removeLayer(l); });

    // poligon içinde kalanları ekle
    __kmzPointLayers.forEach(l => {
      if(!l) return;
      if(__layerInsidePolygon(l, polyFeature)){
        allLayers.addLayer(l);
        try{ l.bringToFront && l.bringToFront(); }catch(e){}
      }
    });

    __kmzOtherLayers.forEach(l => {
      if(!l) return;
      if(__layerInsidePolygon(l, polyFeature)){
        allLayers.addLayer(l);
        try{ l.bringToFront && l.bringToFront(); }catch(e){}
      }
    });
  }catch(e){}

  try{ const __st = __computePolygonStats(polyFeature); __renderPolygonPanel(polyName, __st); }catch(e){}

  __setPolygonFilterInfo(polyName);
}


// --- /Bölgeler (poligonlar) ---



let featureToLayers = new Map();

function __indexFeatureLayer(feat, layer){
  if(!feat || !layer) return;
  let arr = featureToLayers.get(feat);
  if(!arr){
    arr = [];
    featureToLayers.set(feat, arr);
  }
  arr.push(layer);
}

function __getActiveBaseFeaturesForSearch(){
  // Eğer bir film seçiliyse (showOnlyFilm), arama sadece o filmin feature'ları içinde çalışsın.
  // Ancak: TEK kelimelik aramada (tokens=1) seçili filme kilitleme; tüm haritada aransın.
  const sel = document.querySelector('.film-title.selected');
  const toks = (window.__currentSearchTokens || []);
  const allowLock = (toks.length >= 2) || (toks.length === 0); // boş aramada film kilidi ok
  if(sel && allowLock){
    const filmName = (sel.textContent || '').trim();
    if(filmName && films && films[filmName]) return films[filmName];
  }
  return allKmzFeatures || [];
}

function __renderFeaturesToMap(feats){
  allLayers.clearLayers();
  const b = L.latLngBounds([]);
  (feats || []).forEach(f=>{
    const layers = featureToLayers.get(f) || [];
    layers.forEach(l=>{
      try{
        allLayers.addLayer(l);
        // bounds toplama: layer tipine göre
        if(l.getLatLng) b.extend(l.getLatLng());
        else if(l.getBounds) b.extend(l.getBounds());
      }catch(e){}
    });
  });
  try{
    if(b.isValid && b.isValid()) map.fitBounds(b.pad(0.08), { padding: [20,20], maxZoom: 16, animate: true });
  }catch(e){}
}


function __escapeRegExp(s){
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Unicode uyumlu arama (Türkçe karakterlerle de çalışsın diye \b yerine Unicode sınırları kullanıyoruz)
function __makeTokenRegex(token){
  const t = (token || '').trim();
  if(!t) return null;

  // Çok kelimeli ifade: parça içinde arama (includes) mantığına uygun basit regex
  if(t.includes(' ')){
    return new RegExp(__escapeRegExp(t), 'iu');
  }

  // Tek kelime: "prefix" eşleşme (kelimenin başından itibaren)
  // (^|[^\p{L}\p{N}_]) token
  return new RegExp('(^|[^\\p{L}\\p{N}_])(' + __escapeRegExp(t) + ')([\\s\\S])?', 'iu');
}



// Akıllı arama:
// - "tırnak içi ifade" tek bir token olarak aranır
// - + kullanılırsa tüm token'lar aynı anda (AND) aranır
// - + yoksa token'lardan herhangi biri (OR) yeter
function __parseSmartQuery(raw){
  const s = (raw || '').trim();
  if(!s) return { raw:'', tokens:[], requireAll:false };

  const tokens = [];
  // çift tırnak içi ifadeleri çek
  const re = /"([^"]+)"/g;
  let m;
  while((m = re.exec(s)) !== null){
    const phrase = (m[1] || '').trim();
    if(phrase) tokens.push(phrase.toLowerCase());
  }
  // tırnaklı kısımları çıkar
  const remainder = s.replace(re, ' ').trim();

  // + işareti AND göstergesi
  const requireAll = remainder.includes('+') || s.includes('+');

  // kalan parçaları + ve boşluklardan böl
  const parts = remainder.split(/\s*\+\s*|\s+/).map(p=>p.trim()).filter(Boolean);
  parts.forEach(p => tokens.push(p.toLowerCase()));

  // boş token temizle
  const clean = tokens.filter(t=>t && t.length);

  const requireAllFinal = requireAll || (clean.length > 1);
  return { raw:s, tokens: clean, requireAll: requireAllFinal };
}

function __matchTextSmart(haystack, parsed){
  const hRaw = (haystack || '');
  const h = __normTr(hRaw);
  const tokensRaw = parsed && parsed.tokens ? parsed.tokens : [];
  if(!tokensRaw.length) return true;

  const wordTokens = [];
  const phraseTokens = [];
  tokensRaw.forEach(t=>{
    const tt = (t || '').trim();
    if(!tt) return;
    if(tt.includes(' ')) phraseTokens.push(__normTr(tt));
    else wordTokens.push(__normTr(tt));
  });

  const matchOne = (tokNorm) => {
    if(!tokNorm) return false;
    // phrase: anywhere
    if(tokNorm.includes(' ')) return h.includes(tokNorm);
    // single: prefix of any word
    const parts = h.split(/[^a-z0-9]+/g).filter(Boolean);
    for(let i=0;i<parts.length;i++){
      if(parts[i].startsWith(tokNorm)) return true;
    }
    return false;
  };

  const allTokens = phraseTokens.concat(wordTokens);
  if(parsed.requireAll){
    return allTokens.every(t => matchOne(t));
  }
  return allTokens.some(t => matchOne(t));
}




function __normTr(str){
  return (str || '')
    .toLocaleLowerCase('tr-TR')
    .normalize('NFD')
    .replace(/\p{M}+/gu,'')
    .replace(/ı/g,'i');
}

function __escapeHtml(str){
  return (str || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function __highlightSmart(text, parsed){
  const tokens = (parsed && parsed.tokens) ? parsed.tokens.slice() : [];
  let out = __escapeHtml(text || '');
  if(!tokens.length) return out;

  tokens.sort((a,b)=>b.length-a.length);

  tokens.forEach(tok=>{
    if(!tok) return;
    const rx = __makeTokenRegex(tok);
    if(!rx) return;

    // Tek kelime regex'inde yakalanan grup(2) token, çevresi grup1/grup3 — bunları koruyarak mark'la
    if(tok.includes(' ')){
      out = out.replace(new RegExp(__escapeRegExp(tok), 'giu'), m => '<mark>' + m + '</mark>');
    } else {
      out = out.replace(rx, function(){
        const full = arguments[0];
        const pre  = (typeof arguments[1] === 'string') ? arguments[1] : '';
        const mid  = (typeof arguments[2] === 'string') ? arguments[2] : '';
        // Eğer regex 3. grubu üretmüyorsa, arguments[3] offset (number) olabilir.
        const post = (typeof arguments[3] === 'string') ? arguments[3] : '';
        return pre + '<mark>' + mid + '</mark>' + post;
      });
    }
  });

  return out;
}

function __applySearchDeterministic(q){
  const parsed = __parseSmartQuery(q);
  try{ window.__currentSearchTokens = (parsed && parsed.tokens) ? parsed.tokens.slice() : []; }catch(e){ window.__currentSearchTokens = []; }
  const baseFeats = __getActiveBaseFeaturesForSearch();

  if(!parsed.tokens.length){
    // Arama boşsa:
    // - Eğer film seçili değilse: haritayı DEFAULT görünümüne döndür (fitBounds yapma; çok uzaklaşabiliyor)
    // - Eğer film seçiliyse: o filmin öğelerini çizip fitBounds ile odakla
    try{ window.__lastSearchMatchCount = baseFeats.length; }catch(e){}

    const selectedFilmEl = document.querySelector('.film-title.selected');
  const __q = (q||'').trim();
  const __tok = __q ? __q.split(/\s+/).filter(Boolean) : [];
  const __hasMekanMark = !!document.querySelector('.mekan-list li mark');
  const __lockToSelectedFilm = !(__tok.length === 1 && __hasMekanMark);

    if(!selectedFilmEl){
      try{
        // base feature'ları haritada göster ama zoom değiştirme
        allLayers.clearLayers();
        (baseFeats || []).forEach(f=>{
          const layers = featureToLayers.get(f) || [];
          layers.forEach(l=>{
            try{ allLayers.addLayer(l); }catch(err){}
          });
        });
      }catch(err){}

      try{ map.setView(DEFAULT_CENTER, DEFAULT_ZOOM, { animate: true }); }catch(err){}
      try{ if(window.__updateSearchStatus) window.__updateSearchStatus(); }catch(e){}
      return;
    }

    __renderFeaturesToMap(baseFeats);
    try{ if(window.__updateSearchStatus) window.__updateSearchStatus(); }catch(e){}
    return;
  }

  const matched = [];
  baseFeats.forEach(f=>{
    const props = f && f.properties ? f.properties : {};
    // Mekân adı + film klasörü (film adı/yıl/yönetmen metni UI'de varsa) birlikte aranır
    const hay = (String(props.name || '') + ' ' + String(props.folder || props.Folder || '')).toString();
    if(__matchTextSmart(hay, parsed)) matched.push(f);
  });

  try{ window.__lastSearchMatchCount = matched.length; }catch(e){}
  __renderFeaturesToMap(matched);
  try{ if(window.__updateSearchStatus) window.__updateSearchStatus(); }catch(e){}
}

// Harita odak/zoom'unu her tuş vuruşunda zıplatmamak için debounce
let __searchDebounceTimer = null;
function __applySearchDeterministicDebounced(qRaw){
  if(__searchDebounceTimer) clearTimeout(__searchDebounceTimer);
  __searchDebounceTimer = setTimeout(() => {
    __applySearchDeterministic(qRaw);
  }, 250);
}


function loadKmzs(onComplete){
  fetch('kmzs.geojson').then(r=>r.json()).then(data=>{
    films = {}; featureToLayer = new Map(); featureToLayers = new Map(); allLayers.clearLayers(); __kmzPointLayers = []; __kmzOtherLayers = [];
    allKmzFeatures = [];
    data.features.forEach(f=>{
      let year = null;
      if (f.properties) {
        if (typeof f.properties.year === 'number') {
          year = f.properties.year;
        } else {
          const folderStr = f.properties.folder || '';
          const ym = folderStr.match(/\b(19[0-9]{2}|20[0-2][0-9])\b/);
          if (ym) year = parseInt(ym[0]);
        }
        if (year) f.properties._year = year;
      }
      allKmzFeatures.push(f);
      const folder = cleanFolderName(f.properties?.folder) || "Bilinmeyen Film";
      const name = f.properties?.name || "(Adsız Mekân)";
      if(!films[folder]) films[folder]=[];
      films[folder].push(f);

      const geom = f.geometry;
      if(!geom) return;

      const styleProps = f.properties?.style || {};
      const color = styleProps.fillColor || '#e63946';
      let layer = null;
      if(geom.type === 'Point'){
        const coords = [geom.coordinates[1], geom.coordinates[0]];
        const radius = styleProps.radius || 6;
        layer = L.circleMarker(coords, {pane:'markerPane', renderer: hitRenderer, 
          radius,
          color,
          fillColor: styleProps.fillColor || color,
          fillOpacity: ('fillOpacity' in styleProps) ? styleProps.fillOpacity : 1
        });
      } else if(geom.type === 'MultiPoint'){
        const coords = geom.coordinates.map(c => [c[1], c[0]]);
        const group = L.featureGroup(coords.map(c => L.circleMarker(c, {pane:'markerPane', renderer: hitRenderer, radius: styleProps.radius||6, color, fillColor: styleProps.fillColor||color, fillOpacity: ('fillOpacity' in styleProps)? styleProps.fillOpacity:1})));
        layer = group;
      } else if(geom.type === 'LineString' || geom.type === 'MultiLineString'){
        const coords = (geom.type === 'LineString') ? geom.coordinates.map(c => [c[1], c[0]]) : geom.coordinates.map(line => line.map(c => [c[1], c[0]]));
        layer = (geom.type === 'LineString') ? L.polyline(coords, {pane:'linePane', renderer: hitRenderer, color: color, weight: 3, opacity: 0.9}) : L.featureGroup(coords.map(line => L.polyline(line, {pane:'linePane', renderer: hitRenderer, color: color, weight:3, opacity:0.9})));
      } else if(geom.type === 'Polygon' || geom.type === 'MultiPolygon'){
        const coords = (geom.type === 'Polygon') ? geom.coordinates.map(ring => ring.map(c => [c[1], c[0]])) : geom.coordinates.map(poly => poly.map(ring => ring.map(c => [c[1], c[0]])));
        layer = (geom.type === 'Polygon') ? L.polygon(coords, {pane:'polygonPane', renderer: hitRenderer, color: color, weight:2, fillColor: color, fillOpacity:0.3}) : L.featureGroup(coords.map(poly => L.polygon(poly, {renderer: hitRenderer, color: color, weight:2, fillColor: color, fillOpacity:0.3})));
      }

      if(layer){

const props = f.properties || {};
let desc = props.description || '';
let rawImgs = (desc.match(/<img[^>]*>/gi) || []);
desc = desc.replace(/<img[^>]*>/gi, '').trim();

let imgs = [];
if (Array.isArray(props.images)) {
  imgs = props.images.map(src => `<img class='carousel-image' src="${src}" alt="">`);
} else {
  if (props.image) rawImgs.push(`<img class='carousel-image' src="${props.image}" alt="">`);
  imgs = rawImgs;
}

let popup = `<div style="font-family:-apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif !important;">`;
popup += `<div style="font-weight:700;font-size:11pt;margin-bottom:4px;">${name}</div>`;
popup += `<div style="font-weight:500;font-size:10pt;margin-bottom:6px;">${folder}</div>`;
if(desc){ popup += `<div style="font-weight:400;font-size:9pt;margin-bottom:8px;">${desc}</div>`; }

if (imgs.length === 1) {
  popup += imgs[0].replace("carousel-image", "");
} else if (imgs.length > 1) {
  imgs = imgs.map((im,i)=>im.replace("carousel-image", i===0 ? "carousel-image active" : "carousel-image"));
  popup += `
    <div class="carousel-container">
      ${imgs.join('')}
      <div class="carousel-controls">
        <div class="carousel-buttons">
          <button class="carousel-btn prev" onclick="carouselPrev(this)">‹</button>
          <button class="carousel-btn next" onclick="carouselNext(this)">›</button>
        </div>
        <div class="carousel-counter">1 / ${imgs.length}</div>
      </div>
    </div>`;
}
popup += `</div>`;
if(layer.getLayers && typeof layer.getLayers === 'function'){
          layer.getLayers().forEach(ch => { if(ch.bindPopup) ch.bindPopup(popup); ch.feature = f; allLayers.addLayer(ch); featureToLayer.set(f, ch); __indexFeatureLayer(f, ch); try{ __wireClickGate(ch); }catch(e){}; if (ch.on) {
      ch.on('click', function(e){
        try{ if(!__markerClickGate(ch, e)) return; }catch(err){}
        if(!__markerClickGate(this, e)) return;
        let tc=null;
        if (ch.getLatLng) tc=ch.getLatLng();
        else if (ch.getBounds) tc=ch.getBounds().getCenter();
        if (tc) map.panTo(tc,{animate:true});
      });
    }
    });
        } else {

           if(layer.bindPopup) layer.bindPopup(popup);
          try{ __wireClickGate(layer); }catch(e){}

if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
  layer.off('click'); // varsa eski click eventini kaldır
  layer.on('click', function (e) {
    try{ if(!__markerClickGate(layer, e)) return; }catch(err){}
    if(!__markerClickGate(layer, e)) return;
    if(!__markerClickGate(this, e)) return;
    const center = layer.getBounds().getCenter();
    map.openPopup(popup, center);
  });
}

          layer.feature = f;
          // kmzs layer indeksleri (poligon filtresi için)
          try{
            if(geom && (geom.type === 'Point' || geom.type === 'MultiPoint')) __kmzPointLayers.push(layer);
            else __kmzOtherLayers.push(layer);
          }catch(e){}
          allLayers.addLayer(layer);
          featureToLayer.set(f, layer); __indexFeatureLayer(f, layer); if (layer.on) {
      layer.on('click', function(e){
        try{ if(!__markerClickGate(layer, e)) return; }catch(err){}
        if(!__markerClickGate(this, e)) return;
        let tc=null;
        if (layer.getLatLng) tc=layer.getLatLng();
        else if (layer.getBounds) tc=layer.getBounds().getCenter();
        else if (layer.getLayers && typeof layer.getLayers==='function'){
          try{
            const gb=L.latLngBounds([]);
            layer.getLayers().forEach(sub=>{
              if(sub.getLatLng) gb.extend(sub.getLatLng());
              else if(sub.getBounds) gb.extend(sub.getBounds());
            });
            if(gb.isValid && gb.isValid()) tc=gb.getCenter();
          }catch(e){}
        }
        if (tc) map.panTo(tc,{animate:true});
      });
    }
  if (layer.on) {
    layer.on('click', function() {
      let targetCenter = null;
      if (layer.getLatLng) targetCenter = layer.getLatLng();
      else if (layer.getBounds) targetCenter = layer.getBounds().getCenter();
      else if (layer.getLayers && typeof layer.getLayers === 'function') {
        try {
          const groupBounds = L.latLngBounds([]);
          layer.getLayers().forEach(sub => {
            if (sub.getLatLng) groupBounds.extend(sub.getLatLng());
            else if (sub.getBounds) groupBounds.extend(sub.getBounds());
          });
          if (groupBounds.isValid()) targetCenter = groupBounds.getCenter();
        } catch (err) {}
      }
      if (targetCenter) map.panTo(targetCenter, { animate: true });
    });
  }

        }
      }
    });

    try{
      const b=allLayers.getBounds();
      if(b && b.isValid && b.isValid()) map.fitBounds(b.pad(0.08));
    }catch(e){ map.setView([39.93,32.85],11); }

    const filmList = document.getElementById('film-list');
    filmList.innerHTML = '';
    Object.keys(films)
    .sort((a,b)=>{
      const ya=parseInt((a.match(/\d{4}/)||[0])[0]);
      const yb=parseInt((b.match(/\d{4}/)||[0])[0]);
      return (ya||9999)-(yb||9999);
    })
    .forEach(film=>{
      const div=document.createElement('div');
      div.className='film';
      const title=document.createElement('div');
      title.className='film-title';
      title.textContent=film;
      const ul=document.createElement('ul');
      ul.className='mekan-list';

      films[film].forEach(feat=>{
        const li=document.createElement('li');
        li.textContent=feat.properties.name||'(Adsız Mekan)';
        li.dataset.rawText = li.textContent;
        li.onclick = (e) => {
  e.stopPropagation();
  const layer = featureToLayer.get(feat);
  if (!layer) return;

  let targetCenter = null;
  let bounds = L.latLngBounds([]);

  if (layer.getLatLng) {
    targetCenter = layer.getLatLng();
  }

  else if (layer.getBounds) {
    bounds.extend(layer.getBounds());
  }

  else if (layer.getLayers && typeof layer.getLayers === "function") {
    layer.getLayers().forEach((sub) => {
      if (sub.getLatLng) bounds.extend(sub.getLatLng());
      else if (sub.getBounds) bounds.extend(sub.getBounds());
    });
  }

  if (bounds.isValid && bounds.isValid()) {
    targetCenter = bounds.getCenter();
  }

  if (targetCenter) {
    map.setView(targetCenter, 16, { animate: true });
    setTimeout(() => map.panTo(targetCenter, { animate: true }), 200);
  }


  window.__popupFromList = true;


  // Open popup for the clicked item (mekân/rota) when available
  try{
    if(layer.openPopup){
      layer.openPopup();
    } else if (layer.getLayers && typeof layer.getLayers === "function") {
      const subs = layer.getLayers();
      const firstWithPopup = (subs && subs.find) ? subs.find(l => l && l.openPopup) : null;
      const sub = firstWithPopup || (subs ? subs[0] : null);
      if(sub && sub.openPopup) sub.openPopup();
      else if(sub && sub.fire) sub.fire('click');
    } else if(layer.fire){
      layer.fire('click');
    }
  }catch(err){}


  if (window.innerWidth <= 768) {
    const sidebar = document.getElementById("sidebar");
    const toggle = document.getElementById("toggle-btn");
    const arrow = toggle.querySelector("span");
    sidebar.classList.add("closed");
    toggle.style.left = "0";
    arrow.textContent = "▸";
  }
};
        ul.appendChild(li);
      });

      title.onclick = function(e) {
  document.querySelectorAll('.mekan-list').forEach(list => {
    if (list !== ul) list.style.display = 'none';
  });

  showOnlyFilm(film);

  ul.style.display = (ul.style.display === 'none' || ul.style.display === '') ? 'block' : 'none';
};
      div.appendChild(title);
      div.appendChild(ul);
      filmList.appendChild(div);
    });

    const searchInput = document.getElementById('search');
    const clearBtn = document.getElementById('search-clear');
    const statusEl = document.getElementById('search-status');

    // UI helpers
    window.__updateSearchStatus = function(){
      try{
        const q = (searchInput && searchInput.value) ? searchInput.value.trim() : '';
        if(clearBtn) clearBtn.style.display = q ? 'inline-flex' : 'none';

        const visibleFilms = Array.from(document.querySelectorAll('#film-list .film'))
          .filter(d => (d.style.display !== 'none')).length;

        const matchCount = (typeof window.__lastSearchMatchCount === 'number') ? window.__lastSearchMatchCount : null;

        if(statusEl){
          if(!q){
            statusEl.textContent = 'Arama boş. Tüm içerik gösteriliyor.';
          } else {
            const mc = (matchCount === null) ? '' : (' • Haritada ' + matchCount.toLocaleString('tr-TR') + ' eşleşme');
            statusEl.textContent = visibleFilms.toLocaleString('tr-TR') + ' film görünür' + mc;
          }
        }
      }catch(e){}
    };

    if(clearBtn){
      clearBtn.addEventListener('click', () => {
        try{ searchInput.value = ''; }catch(e){}
        try{ searchInput.dispatchEvent(new Event('input', {bubbles:true})); }catch(e){}
        try{ searchInput.focus(); }catch(e){}
      });
    }

    // Chip kısayolları: input'a örnek ekle / imleci koru
    document.querySelectorAll('.search-chips .chip').forEach(ch => {
      ch.addEventListener('click', () => {
        const add = ch.getAttribute('data-insert') || '';
        if(!add) return;

        const v = (searchInput.value || '');
        // Eğer kullanıcı film:/yıl:/yönetmen: gibi bir prefix seçtiyse, mevcut metnin sonuna bir boşlukla ekle
        const sep = v && !v.endsWith(' ') ? ' ' : '';
        searchInput.value = v + sep + add + (add.endsWith(':') ? ' ' : ' ');
        try{ searchInput.focus(); }catch(e){}
        try{ searchInput.dispatchEvent(new Event('input', {bubbles:true})); }catch(e){}
      });
    });

    // ESC ile temizle
    searchInput.addEventListener('keydown', (ev) => {
      if(ev && ev.key === 'Escape'){
        ev.preventDefault();
        if(clearBtn) clearBtn.click();
      }
    });


    searchInput.addEventListener('input',(e)=>{
      const qRaw = e.target.value;
      const parsed = __parseSmartQuery(qRaw);
      __applySearchDeterministicDebounced(qRaw);
document.querySelectorAll('.film').forEach(div=>{
        const titleEl = div.querySelector('.film-title');
        const titleRaw = (titleEl && (titleEl.dataset.rawText || titleEl.textContent)) ? (titleEl.dataset.rawText || titleEl.textContent) : '';
        const liNodes = Array.from(div.querySelectorAll('li'));
        const lisRaw = liNodes.map(li => (li.dataset.rawText || li.textContent) || '');
        const hayAll = (titleRaw + ' ' + lisRaw.join(' ')).toLowerCase();
        const match = !parsed.tokens.length || __matchTextSmart(hayAll, parsed);
        div.style.display = match ? 'block' : 'none';

        if(parsed.tokens.length){
          // highlight + renk ayarı mark ile yapılacak
          try{
            const titleEl2 = div.querySelector('.film-title');
            if(titleEl2){
              if(!titleEl2.dataset.rawText) titleEl2.dataset.rawText = titleEl2.textContent;
              const ttxt = titleEl2.dataset.rawText || titleEl2.textContent;
              titleEl2.innerHTML = __highlightSmart(ttxt, parsed);

              // Film adı birebir eşleştiyse (TR normalize): bu filmin tüm mekânlarını göster.
              // Not: Film başlığında parantez içi (yönetmen/yıl) varsa, parantez öncesini de kabul ediyoruz.
              let __exactFilmMatch = false;
              try{
                const qraw = (parsed && parsed.raw) ? String(parsed.raw).trim() : String(searchInput.value||'').trim();
                const filmRaw = String(ttxt || '').trim();
                const filmNameOnly = filmRaw.split('(')[0].trim();
                const nq = __normTR(qraw);
                __exactFilmMatch = (nq && (nq === __normTR(filmRaw) || nq === __normTR(filmNameOnly)));
              }catch(e){ __exactFilmMatch = false; }
            }
          }catch(e){}
          liNodes.forEach(li=>{
            const text = li.dataset.rawText || li.textContent;
            li.innerHTML = __highlightSmart(text, parsed);
          });

          // eşleşen mekan(lar)ı listenin en üstüne taşı
          const ul = div.querySelector('.mekan-list');
          if (ul) {
            const matchingLis = [];
            const nonMatchingLis = [];
            Array.from(ul.querySelectorAll('li')).forEach(li=>{
              const t = (li.dataset.rawText || li.textContent).toLowerCase();
              if (__matchTextSmart(t, parsed)) matchingLis.push(li);
              else nonMatchingLis.push(li);
            });
            // Eşleşenleri vurgulu, eşleşmeyenleri biraz soluk göster
            
            // Eşleşenler kalsın, eşleşmeyenler görünmesin (arama sonucu ekranı)
            
            try{
              if(__exactFilmMatch){
                // Film adı birebir eşleşti: tüm mekânlar görünsün.
                Array.from(ul.querySelectorAll('li')).forEach(li=>{ li.classList.remove('search-nonmatch'); li.style.display='list-item'; });
              } else {
                matchingLis.forEach(li=>{
                  li.classList.remove('search-nonmatch');
                  li.style.display = 'list-item';
                });
                nonMatchingLis.forEach(li=>{
                  li.classList.add('search-nonmatch');
                  li.style.display = 'none';
                });
              }
            }catch(e){}
// Aramada eşleşen mekân varsa bu filmin listesini otomatik AÇ
            try{
              if(matchingLis.length){
                ul.style.display = 'block';
                ul.dataset.openedBySearch = '1';
              } else {
                // eşleşen mekân yoksa: kullanıcı manuel açmadıysa kapalı kalsın
                if(!ul.dataset.userToggled) ul.style.display = 'none';
                try{ nonMatchingLis.forEach(li=>li.style.display='none'); }catch(_e){}
              }
            }catch(e){}

            ul.innerHTML = '';
            matchingLis.concat(nonMatchingLis).forEach(li=>ul.appendChild(li));
          }
        } else {

          // Arama temizlendiyse: arama yüzünden açılan mekân listelerini geri kapat (kullanıcı manuel değiştirmediyse)
          try{
            const ul = div.querySelector('.mekan-list');
            if(ul){
              Array.from(ul.querySelectorAll('li')).forEach(li=>{ li.classList.remove('search-nonmatch'); li.style.display=''; });
              if(ul.dataset && ul.dataset.openedBySearch === '1' && !ul.dataset.userToggled){
                ul.style.display = 'none';
              }
              try{ delete ul.dataset.openedBySearch; }catch(_e){}
            }
          }catch(e){}

          // arama kutusu boşsa highlight'ları temizle
          try{
            const titleEl2 = div.querySelector('.film-title');
            if(titleEl2){ titleEl2.innerHTML = __escapeHtml(titleEl2.dataset.rawText || titleEl2.textContent); }
          }catch(e){}
          liNodes.forEach(li=> { li.innerHTML = __escapeHtml(li.dataset.rawText || li.textContent); });
        }
      });
      try{ if(window.__updateSearchStatus) window.__updateSearchStatus(); }catch(e){}
    });

    try{ if(window.__updateSearchStatus) window.__updateSearchStatus(); }catch(e){}
    if(onComplete) onComplete();
    clearFilterInfo();
  }).catch(err=>{
    console.error('kmzs.geojson yükleme hatası', err);
    if(onComplete) onComplete(err);
  });
}

function loadHeatmap(periodKey){
  clearFilterInfo();
  allLayers.clearLayers();
  if (!allKmzFeatures.length) return;

  let minYear = 0, maxYear = 9999;
  if (periodKey === '1966-1980') { minYear = 1966; maxYear = 1980; }
  else if (periodKey === '1988-2001') { minYear = 1988; maxYear = 2001; }
  else if (periodKey === '2010-2022') { minYear = 2010; maxYear = 2022; }

  const points = [];

  allKmzFeatures.forEach(f => {
    const props = f.properties || {};
    const year = props._year;
    if (!year || year < minYear || year > maxYear) return;

    const layer = featureToLayer.get(f);
    if (!layer) return;

    const addPointFromLatLng = (latlng) => {
      if (!latlng) return;
      points.push([latlng.lat, latlng.lng, 1.6]);
    };

    if (layer.getLatLng) {
      addPointFromLatLng(layer.getLatLng());
    } else if (layer.getBounds) {
      addPointFromLatLng(layer.getBounds().getCenter());
    } else if (layer.getLayers && typeof layer.getLayers === 'function') {
      try{
        const groupBounds = L.latLngBounds([]);
        layer.getLayers().forEach(sub => {
          if (sub.getLatLng) groupBounds.extend(sub.getLatLng());
          else if (sub.getBounds) groupBounds.extend(sub.getBounds());
        });
        if (groupBounds.isValid && groupBounds.isValid()) {
          addPointFromLatLng(groupBounds.getCenter());
        }
      }catch(e){}
    }

    if (window.__updateScrollHint) setTimeout(window.__updateScrollHint, 120);
  });

  if (!points.length) {
    console.warn('Seçilen dönem için heatmap noktası bulunamadı.');
    return;
  }
              try{ if(ul) ul.style.display = 'block'; }catch(e){}

  L.heatLayer(points, {
    radius: 42,
    blur: 26,
    maxZoom: 19,
    max: 1.0,
    minOpacity: 0.25,
    gradient: {
      0.0: '#000000',
      0.3: '#2b0000',
      0.5: '#660000',
      0.7: '#b30000',
      0.85: '#ff4500',
      1.0: '#ffd000'
    }
  }).addTo(allLayers);

  try{
    const b = allLayers.getBounds();
    if (b && b.isValid && b.isValid()) map.fitBounds(b.pad(0.08));
  }catch(e){}
}

function clearData(){ allLayers.clearLayers(); clearFilterInfo(); }


function pulseLayer(layer){
  try{
    if(!layer) return;
    if(typeof layer.setRadius === 'function' && (layer instanceof L.CircleMarker || layer instanceof L.Circle)){
      var orig = layer.options && (layer.options.radius || layer.getRadius && layer.getRadius()) ? (layer.getRadius ? layer.getRadius() : layer.options.radius) : 6;
      var bigger = Math.round(orig * 2.5);
      layer.setRadius(bigger);
      setTimeout(function(){ try{ layer.setRadius(orig); }catch(e){} }, 1000);
    } else if(typeof layer.setStyle === 'function'){
      var origWeight = (layer.options && layer.options.weight) ? layer.options.weight : 3;
      layer.setStyle({weight: Math.max(2, origWeight*1.8)});
      if(layer.bringToFront) layer.bringToFront();
      setTimeout(function(){ try{ layer.setStyle({weight: origWeight}); }catch(e){} }, 1000);
    }
  }catch(e){ console.error('pulseLayer error', e); }
}

function showFilterInfo(filmName){
  var fi = document.getElementById('map-filter-info');
  fi.innerHTML = '🎞️&nbsp;&nbsp;<strong>' + filmName + '</strong> filmi görüntüleniyor. '
               + '<button class="btn-clear" onclick="restoreAll()">Tümünü Göster</button>';
  fi.style.display = 'block';
}
function clearFilterInfo(){
  var fi = document.getElementById('map-filter-info');
  if(fi){ fi.style.display='none'; fi.innerHTML=''; }
}
function restoreAll(){
  try{ if(window.__resetSidebarSlider) window.__resetSidebarSlider(); }catch(e){}

  try{ clearPolygonFilter(); }catch(e){}
  clearFilterInfo();
  document.querySelectorAll('.film-title').forEach(ft=>ft.classList.remove('selected'));
  loadKmzs();
}
function showOnlyFilm(filmName){
  try{ if(window.__setSidebarSliderForFilm) window.__setSidebarSliderForFilm(filmName); }catch(e){}

  document.querySelectorAll('.film-title').forEach(ft => ft.classList.remove('selected'));
  document.querySelectorAll('.film-title').forEach(ft => {
    if(ft.textContent.trim() === filmName.trim()) ft.classList.add('selected');
  });
  if(!films || !films[filmName]) return;
  allLayers.clearLayers();
  var bounds = L.latLngBounds([]);
  films[filmName].forEach(function(f){
    var layer = featureToLayer.get(f);
    if(!layer) return;
    if(layer.getLayers && typeof layer.getLayers === 'function'){
      layer.getLayers().forEach(function(ch){
        allLayers.addLayer(ch);
        if(ch.getLatLng) bounds.extend(ch.getLatLng());
        else if(ch.getBounds) bounds.extend(ch.getBounds());
      });
    } else {
      allLayers.addLayer(layer);
      if(layer.getLatLng) bounds.extend(layer.getLatLng());
      else if(layer.getBounds) bounds.extend(layer.getBounds());
    }
  });
  try{
    if(bounds.isValid && bounds.isValid()) map.fitBounds(bounds.pad(0.08));
  }catch(e){ console.error('fitBounds error', e); }
  showFilterInfo(filmName);


}



function showPeriodFilterInfo(periodText){
  var fi = document.getElementById('map-filter-info');
  fi.innerHTML =
    '🗺️&nbsp;&nbsp;<strong>' + periodText + ' dönemi</strong> dağılımı ve yoğunluğu görüntüleniyor. ' +
    '<button class="btn-clear" onclick="restoreAllPeriods()">Tümünü Göster</button>';
  fi.style.display = 'block';
}

function restoreAllPeriods(){
  clearFilterInfo();
  document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
  loadFullHeatmap();
}

function loadFullHeatmap(){
  clearFilterInfo();
  allLayers.clearLayers();
  if (!allKmzFeatures.length) return;

  const points = [];

  allKmzFeatures.forEach(f => {
    const layer = featureToLayer.get(f);
    if (!layer) return;

    const addPointFromLatLng = (latlng) => {
      if (!latlng) return;
      points.push([latlng.lat, latlng.lng, 1.6]);
    };

    if (layer.getLatLng) {
      addPointFromLatLng(layer.getLatLng());
    } else if (layer.getBounds) {
      addPointFromLatLng(layer.getBounds().getCenter());
    } else if (layer.getLayers && typeof layer.getLayers === 'function') {
      try{
        const groupBounds = L.latLngBounds([]);
        layer.getLayers().forEach(sub => {
          if (sub.getLatLng) groupBounds.extend(sub.getLatLng());
          else if (sub.getBounds) groupBounds.extend(sub.getBounds());
        });
        if (groupBounds.isValid && groupBounds.isValid()) {
          addPointFromLatLng(groupBounds.getCenter());
        }
      }catch(e){}
    }
  });

  if (!points.length) {
    console.warn('Tüm dönemler için heatmap noktası bulunamadı.');
    return;
  }

  L.heatLayer(points, {
    radius: 42,
    blur: 26,
    maxZoom: 19,
    max: 1.0,
    minOpacity: 0.25,
    gradient: {
      0.0: '#000000',
      0.3: '#2b0000',
      0.5: '#660000',
      0.7: '#b30000',
      0.85: '#ff4500',
      1.0: '#ffd000'
    }
  }).addTo(allLayers);

  try{
    const b = allLayers.getBounds();
    if (b && b.isValid && b.isValid()) map.fitBounds(b.pad(0.08));
  }catch(e){}
}

const sidebar=document.getElementById('sidebar');
const toggle=document.getElementById('toggle-btn');
const arrow=toggle.querySelector('span');
toggle.addEventListener('click', () => {
  sidebar.classList.toggle('closed');
  const isClosed = sidebar.classList.contains('closed');

  if (isClosed) {
    toggle.style.left = '0';
    arrow.textContent = '▸';
  } else {
    toggle.style.left = '340px';
    arrow.textContent = '◂';
  }

  map.invalidateSize();
});





document.querySelectorAll('.tab-btn').forEach(btn=>{
  btn.addEventListener('click', () => {
    // içerikleri kapat
    document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active-visible'));

    // aktif sekme butonu
    document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');

    const tab = btn.dataset.tab;

    // Filmler sekmesinden (Tab1) çıkınca slider'ı default görsele döndür
    try{ if(tab !== 'filmler' && window.__resetSidebarSlider) window.__resetSidebarSlider(); }catch(e){}

    // Tab3 dışına çıkarken poligon katmanını kaldır
    try{ if(tab !== 'bolgeler' && typeof polygonLayers !== 'undefined') polygonLayers.clearLayers(); }catch(e){}

    // içerikleri aç/kapat
    document.getElementById('tab-filmler').classList.toggle('active-visible', tab === 'filmler');
    document.getElementById('tab-yogunluk').classList.toggle('active-visible', tab === 'yogunluk');
    const bolgelerTab = document.getElementById('tab-bolgeler');
    if(bolgelerTab) bolgelerTab.classList.toggle('active-visible', tab === 'bolgeler');

    // Sekme değişiminde Leaflet yeniden boyutlandırma (gizli container'dan gelince şart)
    setTimeout(function(){ try{ map.invalidateSize(); }catch(e){} }, 60);

    if(tab === 'filmler'){
      document.getElementById('search').style.display = 'block';
      document.getElementById('film-list').style.display = 'block';
      loadKmzs();
    } else if(tab === 'yogunluk'){
      document.getElementById('search').style.display = 'none';
      document.getElementById('film-list').style.display = 'none';
      document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
      loadFullHeatmap();
      clearFilterInfo();
      map.setView(DEFAULT_CENTER, DEFAULT_ZOOM, { animate: true });
    } else if(tab === 'bolgeler'){
      document.getElementById('search').style.display = 'none';
      document.getElementById('film-list').style.display = 'none';
      document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
      clearFilterInfo();
      // Tab3: önce sadece poligonlar görünsün; bölge seçilince içerideki marker/rota görünsün
      try{ allLayers.clearLayers(); }catch(e){}
      loadKmzs(function(){
        try{ __activePolygonFeature = null; __activePolygonName = null; __activePolygonLayer = null; }catch(e){}
        try{ __clearPolygonPanel && __clearPolygonPanel(); }catch(e){}
        try{ allLayers.clearLayers(); }catch(e){}
        loadPolygons();
      });
    } else {
      document.getElementById('search').style.display = 'none';
      document.getElementById('film-list').style.display = 'none';
      clearData();
    }
  });
});


document.querySelectorAll('.period-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const periodKey = btn.getAttribute('data-period');
    const yogunlukTabBtn = document.querySelector('.tab-btn[data-tab="yogunluk"]');
    if (yogunlukTabBtn && yogunlukTabBtn.classList.contains('active')) {
      loadHeatmap(periodKey);

      const periodText = btn.textContent.split(':')[0].trim();
      showPeriodFilterInfo(periodText);
    
      // Mobilde: Tab2 butonuna basınca sidebar kapansın
      try{
        if(window.innerWidth <= 768){ closeSidebar(); }
      }catch(e){}
}
  });
});

loadKmzs();
document.getElementById('tab-filmler').classList.add('active-visible');
document.getElementById('tab-filmler').classList.add('active-visible');
document.querySelector('.tab-btn[data-tab="filmler"]').classList.add('active');

</script>


<script>
// --- Sidebar scroll ipucu (Tab3: seçili poligon film listesi aşağı uzuyorsa) ---
(function initBolgelerScrollHint(){
  const tabBolgeler = document.getElementById('tab-bolgeler');
  const scrollHint = document.getElementById('scroll-hint-bolgeler');
  if(!tabBolgeler || !scrollHint) return;

  function isBolgelerActive(){
    return tabBolgeler.classList.contains('active-visible');
  }

  function getScroller(){
    const panel = document.getElementById('polygon-panel');
    if(panel){
      return panel.querySelector('.polygon-scroll') || panel;
    }
    return tabBolgeler;
  }

  function updateBolgelerHint(){
    const panel = document.getElementById('polygon-panel');
    const panelVisible = !!(panel && panel.style && panel.style.display !== 'none');
    const list = document.getElementById('polygon-film-list');
    const hasList = !!(list && list.children && list.children.length);

    const scroller = getScroller();
    if(!scroller) return;

    const canScroll = scroller.scrollHeight > (scroller.clientHeight + 6);
    const nearTop = scroller.scrollTop < 8;

    if (isBolgelerActive() && panelVisible && hasList && canScroll && nearTop) {
      scrollHint.style.display = 'flex';
    } else {
      scrollHint.style.display = 'none';
    }
  }

  function bindScroller(){
    const scroller = getScroller();
    if(!scroller) return;
    scroller.addEventListener('scroll', updateBolgelerHint, {passive:true});
  }

  bindScroller();
  window.addEventListener('resize', updateBolgelerHint);

  const obs = new MutationObserver(() => {
    bindScroller();
    updateBolgelerHint();
  });
  obs.observe(tabBolgeler, {childList:true, subtree:true});

  setTimeout(updateBolgelerHint, 80);
})();</script>


<script>
function carouselNext(btn){
  const container = btn.closest('.carousel-container');
  if (!container) return;
  const imgs = container.querySelectorAll('.carousel-image');
  const counter = container.querySelector('.carousel-counter');
  if (!imgs.length) return;
  let i = [...imgs].findIndex(im => im.classList.contains('active'));
  if (i === -1) i = 0;

  imgs[i].classList.remove('active');
  const newIndex = (i + 1) % imgs.length;
  imgs[newIndex].classList.add('active');

  if (counter) {
    counter.textContent = (newIndex + 1) + ' / ' + imgs.length;
  }
}
function carouselPrev(btn){
  const container = btn.closest('.carousel-container');
  if (!container) return;
  const imgs = container.querySelectorAll('.carousel-image');
  const counter = container.querySelector('.carousel-counter');
  if (!imgs.length) return;
  let i = [...imgs].findIndex(im => im.classList.contains('active'));
  if (i === -1) i = 0;

  imgs[i].classList.remove('active');
  const newIndex = (i - 1 + imgs.length) % imgs.length;
  imgs[newIndex].classList.add('active');

  if (counter) {
    counter.textContent = (newIndex + 1) + ' / ' + imgs.length;
  }
}
</script>


<script>
/**
 * Sidebar slider: Film seçimine göre kapak göster.
 * - Default: images/menu-images/m_i.jpg
 * - Film seçilince: images/menu-images/<slug><year>_kapak.jpg
 *   Örn: "Anadolu Leoparı (2021)" -> anadoluleopari2021_kapak.jpg
 */
(function(){
  const DEFAULT_SRC = "images/menu-images/m_i.jpg";
  const imgEl = document.getElementById('sidebar-slider-image');
  if(!imgEl) return;

  function trSlugify(str){
    return String(str || "")
      .toLowerCase()
      .replace(/İ/g,'i').replace(/I/g,'i')
      .replace(/ı/g,'i').replace(/ş/g,'s').replace(/Ş/g,'s')
      .replace(/ç/g,'c').replace(/Ç/g,'c')
      .replace(/ğ/g,'g').replace(/Ğ/g,'g')
      .replace(/ü/g,'u').replace(/Ü/g,'u')
      .replace(/ö/g,'o').replace(/Ö/g,'o')
      .replace(/â/g,'a').replace(/î/g,'i').replace(/û/g,'u')
      .replace(/[^a-z0-9]+/g,'')
      .trim();
  }

  function setSrc(url){
    const target = url || DEFAULT_SRC;
    // Aynıysa bile görünür sınıfını garanti et
    if(imgEl.src && imgEl.src.indexOf(target) !== -1){
      imgEl.classList.add('visible');
      return;
    }
    imgEl.classList.remove('visible');
    setTimeout(() => {
      imgEl.src = target;
      imgEl.onload = () => imgEl.classList.add('visible');
    }, 60);
  }

  function coverFromFilmName(filmName){
    const name = String(filmName || "").trim();
    const yearMatch = name.match(/\b(19\d{2}|20\d{2})\b/);
    if(!yearMatch) return DEFAULT_SRC;
    const year = yearMatch[0];
    const base = name.replace(yearMatch[0], '').replace(/[()]/g,'').trim();
    const slug = trSlugify(base);
    if(!slug) return DEFAULT_SRC;
    return "images/menu-images/" + slug + year + "_kapak.jpg";
  }

  // Global API: diğer kod burayı çağıracak
  window.__setSidebarSliderForFilm = function(filmName){
    try{ setSrc(coverFromFilmName(filmName)); }catch(e){ setSrc(DEFAULT_SRC); }
  };
  window.__resetSidebarSlider = function(){
    try{ setSrc(DEFAULT_SRC); }catch(e){}
  };

  // İlk yükleme: default
  setSrc(DEFAULT_SRC);
})();
</script>
<script>
// --- Scroll ipucu (Tab1 film listesi aşağı doğru uzuyorsa) ---
(function initSidebarScrollHint(){
  const tabFilmler = document.getElementById('tab-filmler');
  const scrollHint = document.getElementById('scroll-hint');
  if(!tabFilmler || !scrollHint) return;

  function getScroller(){
    return tabFilmler.querySelector('.film-scroll') || tabFilmler;
  }

  function isFilmlerActive(){
    return tabFilmler.classList.contains('active-visible');
  }

  function updateScrollHint(){
    const scroller = getScroller();
    if(!scroller) return;

    const canScroll = scroller.scrollHeight > (scroller.clientHeight + 6);
    const nearTop = scroller.scrollTop < 8;

    if (isFilmlerActive() && canScroll && nearTop) {
      scrollHint.style.display = 'flex';
    } else {
      scrollHint.style.display = 'none';
    }
  }

  // scroller hazır olmayabilir; ilk renderdan sonra yeniden bağla
  function bindScroller(){
    const scroller = getScroller();
    if(!scroller) return;
    scroller.addEventListener('scroll', updateScrollHint, {passive:true});
  }

  bindScroller();
  window.addEventListener('resize', updateScrollHint);

  const obs = new MutationObserver(() => {
    // scroller DOM'u değişirse yeniden bağla
    bindScroller();
    updateScrollHint();
  });
  obs.observe(tabFilmler, {childList:true, subtree:true});

  // ilk ölçüm
  setTimeout(updateScrollHint, 60);
})();</script>





<script>
(function(){
  const wrap = document.getElementById('credits-wrap');
  const btn  = document.getElementById('credits-label');
  const content = document.getElementById('credits-content');
  if(!wrap || !btn || !content) return;

  function isMobile(){ return window.innerWidth <= 768; }

  // Desktop'ta hover var; tıklama bir şey yapmasın.
  btn.addEventListener('click', function(){
    if(!isMobile()) return;
    const isOpen = wrap.classList.toggle('open');
    btn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    content.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
  });

  // Ekran boyutu değişince state'i resetle (örn. rotate)
  window.addEventListener('resize', function(){
    if(!isMobile()){
      wrap.classList.remove('open');
      btn.setAttribute('aria-expanded','false');
      content.setAttribute('aria-hidden','true');
    }
  });
})();
</script>


<script>
// --- Scroll ipucu (Tab3: Bölgeler film listesi aşağı doğru uzuyorsa) ---
</script>

<script>
/* Tab2 (Yoğunluk) dönem butonlarını KESİNLİKLE eski haline döndür */
(function restoreTab2Labels(){
  const tab2 = document.getElementById('tab-yogunluk');
  if(!tab2) return;

  const fixes = {
    "1966–1980": "1966–1980: Yeşilçam'ın Modern Ankara'sı",
    "1988–2001": "1988–2001: Neoliberal Çevrim ve Yeni Merkezler",
    "2010–2022": "2010–2022: Dağınık Odak, Parçalı Metropol"
  };

  const buttons = tab2.querySelectorAll('button, .period-btn, .density-btn');
  buttons.forEach(btn => {
    const txt = btn.textContent.trim();
    Object.keys(fixes).forEach(key => {
      if (txt.startsWith(key) && txt !== fixes[key]) {
        btn.textContent = fixes[key];
      }
    });
  });
})();
</script>


<script>
/* Mobilde Tab2 (Yoğunluk) butonlarına basılınca sidebar kapansın */
(function(){
  function isMobile(){ return window.innerWidth <= 768; }
  const sidebar = document.getElementById('sidebar');
  const tab2 = document.getElementById('tab-yogunluk');
  if(!sidebar || !tab2) return;

  function closeSidebar(){
    if(sidebar.classList.contains('open')){
      sidebar.classList.remove('open');
    }
  }

  tab2.addEventListener('click', function(e){
    if(!isMobile()) return;
    const btn = e.target.closest('button');
    if(btn){
      closeSidebar();
    }
  });
})();
</script>


<script>
/* --- SEARCH STRICT helpers --- */
(function(){
  const searchInput = document.getElementById('search');
  if(!searchInput) return;

  function setSearchActive(on){
    document.body.classList.toggle('search-active', !!on);
  }

  // Hook into existing search pipeline by observing highlights (<mark>)
  function refreshMatches(){
    const q = (searchInput.value || '').trim();
    setSearchActive(q.length > 0);

    // Tek kelimede film başlığını "sonuç" saymayı kısıtla:
    // - >=2 kelime: film başlığı eşleşmesi geçerli (AND hissi)
    // - 1 kelime: ancak mekân tarafında hiç eşleşme YOKSA (yani film araması gibi) film başlığı geçerli
    const tokens = q ? q.split(/\s+/).filter(Boolean) : [];
    const anyMekanMarkGlobal = !!document.querySelector('.mekan-list li mark');
    const allowFilmTitleMatch = (tokens.length >= 2) || (!anyMekanMarkGlobal);
    // Map search should NOT lock to selected film when it's a 1-word query with mekan matches
    window.__disableFilmLockForSearch = (tokens.length === 1 && anyMekanMarkGlobal);
    if(window.__disableFilmLockForSearch){
      document.querySelectorAll('.film-title.selected').forEach(el=>el.classList.remove('selected'));
    }



    document.querySelectorAll('.film').forEach(f => {
      const titleHasMark = !!f.querySelector('.film-title mark');
      const anyMekanMarkInFilm = !!f.querySelector('.mekan-list li mark');

      // Film eşleşmesi: mekân eşleşmesi her zaman sayılır; film başlığı ise koşullu
      const filmMatch = anyMekanMarkInFilm || (allowFilmTitleMatch && titleHasMark);
      f.classList.toggle('match-film', filmMatch);

      // Mekân eşleşme sınıfları
      f.querySelectorAll('.mekan-list li').forEach(li => {
        const m = !!li.querySelector('mark');
        li.classList.toggle('match-mekan', m);
      });

      // Film başlığı eşleşti ama film içinde mekân eşleşmesi yoksa: tüm mekânları aç (bağlam)
      if(filmMatch && allowFilmTitleMatch && titleHasMark && !anyMekanMarkInFilm){
        const ul = f.querySelector('.mekan-list');
        if(ul) ul.style.display = 'block';
        f.querySelectorAll('.mekan-list li').forEach(li => { li.style.display = 'list-item'; });
      }

      // auto-open only if there is a matching mekan
      const list = f.querySelector('.mekan-list');
      if(list){
        if(filmMatch) list.style.display = 'block';
      }
    });
  }

  // Re-run after each input (debounced elsewhere, but safe)
  searchInput.addEventListener('input', () => {
    setTimeout(refreshMatches, 0);
  });

  // Clear state when cleared via ESC or clear button
  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape'){
      setSearchActive(false);
    }
  });

})();
</script>


<script>
/* --- SEARCH OVERRIDE (TR-safe, AND on space, strict reset) --- */
(function(){
  const searchInput = document.getElementById('search');
  if(!searchInput) return;

  // Store original order once
  function initOrder(){
    const films = Array.from(document.querySelectorAll('.film'));
    films.forEach((film, fi)=>{
      if(!film.dataset.origIndex) film.dataset.origIndex = String(fi);
      const title = film.querySelector('.film-title');
      if(title && !title.dataset.rawText) title.dataset.rawText = title.textContent;

      const ul = film.querySelector('.mekan-list');
      if(!ul) return;
      const lis = Array.from(ul.querySelectorAll('li'));
      lis.forEach((li, lii)=>{
        if(!li.dataset.origIndex) li.dataset.origIndex = String(lii);
        if(!li.dataset.rawText) li.dataset.rawText = li.textContent;
      });
    });
  }

  function restoreOrder(){
    document.querySelectorAll('.film').forEach(film=>{
      const ul = film.querySelector('.mekan-list');
      if(!ul) return;
      const lis = Array.from(ul.querySelectorAll('li'));
      lis.sort((a,b)=> (parseInt(a.dataset.origIndex||'0',10) - parseInt(b.dataset.origIndex||'0',10)));
      lis.forEach(li=> ul.appendChild(li));
    });
  }

  function resetAll(){
    document.body.classList.remove('search-active');
    document.querySelectorAll('.film').forEach(film=>{
      film.style.display = '';
      const title = film.querySelector('.film-title');
      if(title){
        const raw = title.dataset.rawText || title.textContent;
        title.innerHTML = __escapeHtml(raw);
        title.classList.remove('selected');
      }
      const ul = film.querySelector('.mekan-list');
      if(ul){
        ul.style.display = ''; // default CSS decides
        Array.from(ul.querySelectorAll('li')).forEach(li=>{
          const raw = li.dataset.rawText || li.textContent;
          li.innerHTML = __escapeHtml(raw);
          li.style.display = '';
          li.classList.remove('search-nonmatch');
        });
      }
    });
    restoreOrder();
    try{
      if(typeof __applySearchDeterministic === 'function') __applySearchDeterministic('');
    }catch(e){}
  }

  function apply(){
    const qRaw = (searchInput.value || '');
    const q = qRaw.trim();
    const parsed = __parseSmartQuery(qRaw);

    if(!parsed.tokens.length){
      resetAll();
      return;
    }

    document.body.classList.add('search-active');

    document.querySelectorAll('.film').forEach(film=>{
      const title = film.querySelector('.film-title');
      const titleRaw = title ? (title.dataset.rawText || title.textContent || '') : '';
      const ul = film.querySelector('.mekan-list');
      const lis = ul ? Array.from(ul.querySelectorAll('li')) : [];

      // Decide matches using TR-safe matcher on raw texts
      const filmTitleMatch = __matchTextSmart(titleRaw, parsed);
      const mekanMatches = lis.filter(li=>{
        const raw = li.dataset.rawText || li.textContent || '';
        return __matchTextSmart(raw, parsed);
      });

      const filmVisible = filmTitleMatch || mekanMatches.length > 0;
      film.style.display = filmVisible ? 'block' : 'none';

      // Highlight title always (so film-title match is visible)
      if(title){
        title.innerHTML = __highlightSmart(titleRaw, parsed);
        title.classList.toggle('selected', filmTitleMatch);
      }

      if(!ul) return;

      // Restore order first (in case old handler reordered)
      const orderedLis = lis.slice().sort((a,b)=> (parseInt(a.dataset.origIndex||'0',10) - parseInt(b.dataset.origIndex||'0',10)));
      orderedLis.forEach(li=> ul.appendChild(li));

      // Strict: only matching mekans visible. If film matched but no mekan matched, hide mekan list.
      if(mekanMatches.length > 0){
        ul.style.display = 'block';
        orderedLis.forEach(li=>{
          const raw = li.dataset.rawText || li.textContent || '';
          li.innerHTML = __highlightSmart(raw, parsed);
          const isMatch = __matchTextSmart(raw, parsed);
          li.style.display = isMatch ? 'list-item' : 'none';
        });
      } else {
        ul.style.display = 'none';
        orderedLis.forEach(li=>{
          const raw = li.dataset.rawText || li.textContent || '';
          li.innerHTML = __highlightSmart(raw, parsed); // harmless; li hidden
          li.style.display = 'none';
        });
      }
    });

    // Keep map search in sync
    try{
      if(typeof __applySearchDeterministic === 'function') __applySearchDeterministic(qRaw);
    }catch(e){}
  }

  initOrder();

  // Run after existing handlers
  searchInput.addEventListener('input', ()=> setTimeout(apply, 0));

})();
</script>





<script>
/* --- SEARCH STRICT v9 (NFC-safe, grapheme-safe) --- */
(function(){
  const searchInput = document.getElementById('search');
  if(!searchInput) return;

  // ---- Normalization helpers ----
  function normTR(s){
    return (s||'')
      .normalize('NFC')
      .toLocaleLowerCase('tr-TR')
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
      .replace(/ı/g,'i');
  }
  function tokenize(q){
    return (q||'').trim().split(/\s+/).filter(Boolean);
  }

  // ---- AND match on normalized text ----
  function andMatch(text, q){
    const nt = normTR(text||'');
    const toks = tokenize(q).map(normTR);
    if(!toks.length) return false;
    return toks.every(t => nt.includes(t));
  }

  // ---- NFC-safe highlighter for ALL tokens ----
  function highlightAllNFC(el, q){
    if(!el) return;
    const raw = (el.dataset.rawTextNFC || el.textContent || '').normalize('NFC');
    const toks = tokenize(q).map(normTR).filter(Boolean);
    if(!toks.length){ el.innerHTML = raw; return; }

    let out = raw;
    let cursor = 0;
    let result = '';

    // We will find token occurrences sequentially on normalized text,
    // but slice on NFC raw text to avoid grapheme splits.
    let nraw = normTR(raw);

    // Build list of ranges to mark
    const ranges = [];
    toks.forEach(tok => {
      const idx = nraw.indexOf(tok);
      if(idx >= 0){
        // Map normalized index to NFC index by expanding progressively
        let acc = '';
        let start = null, end = null;
        for(let i=0;i<raw.length;i++){
          acc += normTR(raw[i]);
          if(start===null && acc.length>=idx+1 && acc.slice(0, idx+1).endsWith(tok[0])){
            // tentative start; refine below
            start = i;
          }
          if(start!==null && acc.length>=idx+tok.length){
            end = i+1;
            break;
          }
        }
        if(start!==null && end!==null){
          ranges.push([start,end]);
        }
      }
    });

    // Merge overlapping ranges
    ranges.sort((a,b)=>a[0]-b[0]);
    const merged = [];
    ranges.forEach(r=>{
      if(!merged.length || r[0] > merged[merged.length-1][1]) merged.push(r);
      else merged[merged.length-1][1] = Math.max(merged[merged.length-1][1], r[1]);
    });

    // Build HTML
    let last = 0;
    merged.forEach(([s,e])=>{
      result += raw.slice(last, s) + '<mark>' + raw.slice(s,e) + '</mark>';
      last = e;
    });
    result += raw.slice(last);

    el.innerHTML = result;
  }

  function isExactFilm(titleRaw, q){
    const nq = normTR(q);
    const nameOnly = (titleRaw||'').split('(')[0].trim();
    return nq === normTR(titleRaw) || nq === normTR(nameOnly);
  }

  function refresh(){
    const q = (searchInput.value||'').trim();
    const active = q.length>0;

    document.querySelectorAll('.film').forEach(film=>{
      const title = film.querySelector('.film-title');
      const ul = film.querySelector('.mekan-list');
      const lis = ul ? Array.from(ul.querySelectorAll('li')) : [];

      // Store NFC raw once
      if(title && !title.dataset.rawTextNFC){
        title.dataset.rawTextNFC = (title.dataset.rawText || title.textContent || '').normalize('NFC');
      }
      lis.forEach(li=>{
        if(!li.dataset.rawTextNFC){
          li.dataset.rawTextNFC = (li.dataset.rawText || li.textContent || '').normalize('NFC');
        }
      });

      if(!active){
        film.style.display = '';
        if(title) title.innerHTML = title.dataset.rawTextNFC || title.textContent;
        if(ul) ul.style.display = '';
        lis.forEach(li=> li.style.display = '');
        return;
      }

      const titleRaw = title ? title.dataset.rawTextNFC : '';
      const filmMatched = title ? andMatch(titleRaw, q) : false;
      const exactFilm = title ? isExactFilm(titleRaw, q) : false;

      const mekanMatched = lis.filter(li => andMatch(li.dataset.rawTextNFC||'', q));

      const visible = filmMatched || mekanMatched.length>0;
      film.style.display = visible ? 'block' : 'none';
      if(!visible){
        if(ul) ul.style.display='none';
        lis.forEach(li=>li.style.display='none');
        return;
      }

      // Highlight title tokens safely
      if(title) highlightAllNFC(title, q);

      // Film exact OR multi-token film match -> show all mekans
      const tokCount = tokenize(q).length;
      if(exactFilm || (filmMatched && tokCount>=2)){
        if(ul) ul.style.display='block';
        lis.forEach(li=> li.style.display='list-item');
        return;
      }

      // Otherwise show only matching mekans
      if(ul) ul.style.display='block';
      lis.forEach(li=>{
        if(mekanMatched.includes(li)){
          li.style.display='list-item';
          highlightAllNFC(li, q);
        } else {
          li.style.display='none';
        }
      });
    });
  }

  searchInput.addEventListener('input', ()=> setTimeout(refresh,0));
  setTimeout(refresh,0);
})();
</script>

</body>

</html>
